#!/usr/bin/perl

use strict 'refs';
use warnings;

{
package XPLBuilder;

use URI;
use Cwd;

use LWP::UserAgent;
use HTTP::Request;
our $userAgent = LWP::UserAgent->new;
$userAgent->agent("XPL/0.1 ");

use XML::LibXML;


sub new {
	my $class = shift;
	my $self = {};
	bless($self, $class);
	$self->{requiredDocuments} = {};
	$self->{prefetchedDocuments} = {};
	$self->{params} = {};
	$self->{diskCache} = {};
	$self->{memCache} = {};
	$self->{makeDepend} = 0;
	return $self;
}


sub build() {
	my $self = shift;
	my $href = shift;
	print "var Meeko = {}; Meeko.XPL = {}; Meeko.XPL.params = {}; Meeko.XPL.prefetch = {};\n";
	while (<main::DATA>) {
		print;
	}
	$self->buildFromHref($href) if $href;
}

sub makeDependencies() {
	my $self = shift;
	my $fname = shift;
	my $cwd = getcwd();

	my $baseHref = "file://localhost" . $cwd;
	my $uri = URI->new_abs($fname, $baseHref);
	my $szUri = $uri->as_string();
	my $rq = $self->requestUri($uri);
	$self->process($rq->{responseXML}, {
		handleContext => sub { my ($szUri, $rq) = @_; print($szUri . " "); },
		handlePrefetch => sub { my ($szUri, $rq) = @_; print($szUri . " "); },
		handleScript => sub { my ($szUri, $rq) = @_; print($szUri . " ") if ($szUri); }
	});
}

sub expandParams() {
	my $self = shift;
	my ($text) = @_;
	for my $name (keys %{$self->{params}}) {
		my $value = $self->{params}->{$name};
		$text =~ s/\{$name\}/$value/eg;
	}
	return $text;
}

sub prefetchFromHref() {
	my $self = shift;
	my ($href, $baseHref) = @_;
	$baseHref ||= "file://localhost" . getcwd() . "/";

	my $uri = URI->new_abs($href, $baseHref);
	my $szUri = $uri->as_string();
	if ($self->{diskCache}->{$szUri}) {
		$szUri = "file://" . $self->{diskCache}->{$szUri};
	}
	my $rq = HTTP::Request->new(GET => $szUri);
	my $res = $userAgent->request($rq);
	($res->is_success) or die "Couldn't retrieve " . $href . " --> " . $res->status_line, "\n";
	my $text = $res->content;
	$text =~ s/\\/\\\\/g;
	$text =~ s/'/\\'/g;
	$text =~ s/\t/\\t/g;
	$text =~ s/\r/\\r/g;
	$text =~ s/\n/\\n/g;
	print "Meeko.stuff.xplSystem.prefetch['" . $href . "'] = '" . $text . "';\n";
}

sub buildFromHref() {
	my $self = shift;
	my ($href, $baseHref) = @_;
	$baseHref ||= "file://localhost" . getcwd() . "/";

	my $uri = URI->new_abs($href, $baseHref);
	my $szUri = $uri->as_string();
	$self->{requiredDocuments}->{$szUri} and return;
	if ($self->{diskCache}->{$szUri}) {
		$szUri = "file://" . $self->{diskCache}->{$szUri};
	}
	my $rq = HTTP::Request->new(GET => $szUri);
	my $res = $userAgent->request($rq);
	($res->is_success) or die "Couldn't retrieve " . $href . " --> " . $res->status_line, "\n";
	my $parser = XML::LibXML->new();
	my $document = $parser->parse_string($res->content);
	$self->{requiredDocuments}->{$szUri} = $document;
	
	print "Meeko.stuff.xplSystem.createContext('$href');\n";
	my $node = $document->firstChild;
	while ($node) {
		(1 == $node->nodeType) and last;
		if (7 == $node->nodeType) {
			my $pi = XMLProcessingInstruction->new($node);
			($pi && $pi->target) or next;
			if ("xpl-param" eq $pi->target) {
				print "Meeko.stuff.xplSystem.contexts['$href'].params['" . $pi->attributes->{name} . "'] = '" . $self->expandParams($pi->attributes->{value}) . "';\n";
			}
			elsif ("xpl-require" eq $pi->target) {
				my $href = $self->expandParams($pi->attributes->{href});
				$self->buildFromHref($href, $szUri);
			}
			elsif ("xpl-prefetch" eq $pi->target) {
				my $href = $self->expandParams($pi->attributes->{href});
				$self->prefetchFromHref($href, $szUri);
			}
		}
		$node = $node->nextSibling;
	}
	
	my $head = $document->getElementsByTagName("head")->[0];
	my $scripts = $head->getElementsByTagName("script");
	for my $script (@$scripts) {
		my $scriptSrc = $script->getAttribute("src");
		my $scriptText;
		if ($scriptSrc) {
			my $szScriptUri = URI->new_abs($scriptSrc, $baseHref)->as_string();
			my $rq = HTTP::Request->new(GET => $szScriptUri);
			my $res = $userAgent->request($rq);
			($res->is_success) or die "Couldn't retrieve " . $href . " --> " . $res->status_line, "\n";
			$scriptText = $res->content;
		}
		else {
			$scriptText = $script->textContent;
		}

print <<EOT;
(function() {
	var xplSystem = Meeko.stuff.xplSystem;
	var xplContext = xplSystem.contexts['$href'];
	var logger = xplContext.logger;
	$scriptText
})();
EOT
	}

}

sub requestUri() {
	my $self = shift;
	my ($uri) = @_;
	my $resolvedUri = ($self->{diskCache}->{$uri}) ? "file://" . $self->{diskCache}->{$uri} : $uri;
	my $rq = new XMLHttpRequest;
	$rq->open("GET", $resolvedUri, 0);
	$rq->send("");
	($rq->status == "200") and $self->{memCache}->{$uri} = $rq;
	($rq->responseXML) and $rq->responseXML->documentURI = $uri;
	return $rq;
}

sub resolveUri() {
	my $self = shift;
	my ($uri) = @_;
	return ($self->{diskCache}->{$uri}) ? "file://" . $self->{diskCache}->{$uri} : $uri;
}

sub normalize() {
	my $self = shift;
	my ($href, $baseUri) = @_;
	my $baseURL = new URI($baseUri);
	my $normalURL = new URI($baseURL, $href);
	return $normalURL.toString();
}

} # end XPLBuilder package

{
	
package XMLProcessingInstruction;

sub new {
	my $class = shift;
	my $node = shift;
	($node && 7 == $node->nodeType) or die "Cannot create XMLProcessingInstruction interface";
	my $self = {};
	bless($self, $class);
	$self->{owner} = $node;
	return $self;
}


sub target { return $_[0]->{owner}->nodeName; }
sub data { return $_[0]->{owner}->getData; }
sub attributes {
	my $self = shift;
	my $data = $self->{owner}->getData;
	my %result = $data =~ /(\w+)="([^"]*)"/g;
	return \%result;
}

}

my $usage = "xpl [--disk-cache uri fname] [--param name value] [--make-depend] file\n";
my $href;

my $xplBuilder = new XPLBuilder;
my $n = scalar @ARGV;

for (my $i=0; $i<$n; $i++) {
	my $arg = $ARGV[$i];
	if ("--help" eq $arg || "-?" eq $arg) {
		print STDERR $usage;
		exit 1;
	}
	elsif ("--param" eq $arg) {
		my $name = $ARGV[++$i];
		my $value = $ARGV[++$i];
		$xplBuilder->{params}->{$name} = $value;
		next;
	}
	elsif ("--disk-cache" eq $arg) {
		my $uri = $ARGV[++$i];
		my $fname = $ARGV[++$i];
		$xplBuilder->{diskCache}->{$uri} = $fname;
		next;
	}
	elsif ("--make-depend" eq $arg) {
		$xplBuilder->{makeDepend} = 1;
	}
	elsif ($arg =~ /^-/) {
		print STDERR "Illegal option " . $arg . "\n" . "Usage:" . $usage;
		exit 1;
	}
	
	else {
		if (!$href) { $href = $arg; }
		else {
			print STDERR "Cannot process more than one file.\nUsage: " + $usage;
			quit();
		}
	}
}

if ($xplBuilder->{makeDepend}) { $xplBuilder->makeDependencies($href); }
else { $xplBuilder->build($href); }

__DATA__
if (!Meeko) window.Meeko = {};
if (!Meeko.xpl) Meeko.xpl = (function() {

var Namespace = function() {};
Namespace.enhance = function(dest, src) {
	for (var className in src) {
		var srcClass = src[className];
		var destClass = dest[className];
		if (destClass) {
			for (var propName in srcClass) {
				if ("prototype" == propName) continue;
				if (destClass[propName]) continue;
				else destClass[propName] = srcClass[propName];
			}
			if (srcClass.prototype && null == destClass.prototype) destClass.prototype = {}; // NOTE fixes DOMException on Opera and Safari2
			for (var propName in srcClass.prototype) {
				if (destClass.prototype[propName]) continue;
				else destClass.prototype[propName] = srcClass.prototype[propName];
			}
		}
		else dest[className] = srcClass;
	}
}

var Logger = function(ref) {
	this.ref = ref;
}

Logger.DEBUG = 0;
Logger.INFO = 1;
Logger.WARN = 2;
Logger.ERROR = 3;

Logger.prototype.log = function() { this._log({ message: arguments }); }
Logger.prototype.debug = function() { this._log({ level: Logger.DEBUG, message: arguments }); }
Logger.prototype.info = function() { this._log({ level: Logger.INFO, message: arguments }); }
Logger.prototype.warn = function() { this._log({ level: Logger.WARN, message: arguments }); }
Logger.prototype.error = function() { this._log({ level: Logger.ERROR, message: arguments }); }

Logger.prototype._log = function(data) {
	data.date = new Date;
	data.ref = this.ref;
	data.message = Array.prototype.join.call(data.message, " ");
	if (this._trace) this._trace.log(data);
}

var XPLContext = function(ref) {
	this.params = {};
	this.logger = new Logger(ref);	
}

var XPLSystem = function() {
	this.prefetch = {};
	this.contexts = {};
	this.documentURI = document.documentURI || document.baseURI || document.URL;
	this.boundDocumentURI = this.documentURI; // FIXME orthogonality
}

XPLSystem.prototype.createContext = function(ref) {
	if (null == ref) { ref = 0; for (var text in this.contexts) ref++; } // NOTE default value for ref is the current number of contexts;
	var xplContext = new XPLContext(ref);
	this.contexts[ref] = xplContext;
	xplContext.logger._trace = this.trace;
	return xplContext;
}


var Script = function() {
	this.readyState = "initialized";
}

Script.runList = [];

Script.prototype.run = function(text) {
	function setText(_elt, _text) {
		_elt.text = _text;
		if (!_elt.innerHTML) _elt.appendChild(document.createTextNode(_text));
	}
	var scriptElt = document.createElement("script");
	scriptElt.type = "text/javascript";

	this.scriptElement = scriptElt;
	this.scriptIndex = Script.runList.length;
	Script.runList.push(this);

	this.readyState = "loaded";
	setText(scriptElt, 
		'try {\n' +
		text + '\n' +
		' Meeko.xpl.Script.runList[' + this.scriptIndex + '].readyState = "complete";\n' +
		'}\n' +
		'catch (__xplError__) {\n' +
		' Meeko.xpl.Script.runList[' + this.scriptIndex + '].readyState = "error";\n' +
		'}\n'
	);
	
	var callbackElt = document.createElement("script");
	callbackElt.type = "text/javascript";
	
	this.callbackElement = callbackElt;
	setText(callbackElt,
		'setTimeout(function() { Meeko.xpl.Script.runList[' + this.scriptIndex + '].callback(); }, 0);'
	);

	var head = document.getElementsByTagName("head")[0];
	head.appendChild(scriptElt);
	head.appendChild(callbackElt);
}

Script.prototype.callback = function() {
	var head = this.scriptElement.parentNode;
	head.removeChild(this.scriptElement);
	head.removeChild(this.callbackElement);
	if (this.readyState == "error") {
	}
	else if (this.readyState == "loaded") {
		this.readyState = "syntax-error";
	}
	if (this.onreadystatechange) this.onreadystatechange();
}


return {
	Namespace: Namespace,
	XPLContext: XPLContext,
	XPLSystem: XPLSystem,
	Script: Script
}

})();

Meeko.stuff = {};
Meeko.stuff.xplSystem = new Meeko.xpl.XPLSystem();
var traceWindow = this;
do {
	if (traceWindow && traceWindow.Meeko && traceWindow.Meeko.stuff && traceWindow.Meeko.stuff.trace) {
		Meeko.stuff.xplSystem.trace = {
			_log: traceWindow.Meeko.stuff.trace.log,
			log: function(data) {
				data.url = Meeko.stuff.xplSystem.documentURI; 
				data.boundDocumentURI = Meeko.stuff.xplSystem.boundDocumentURI; // FIXME orthogonality
				this._log(data);
			}
		}
		break;
	}
	if (traceWindow == top) break; // need to break at top because top.parent == top
} while (traceWindow = traceWindow.parent);

if (!Meeko.stuff.xplSystem.trace) {
	Meeko.stuff.xplSystem.trace = {
		log: function(data) {}
	}
}

Meeko.stuff.execScript = function(text, callback) {
	var script = new Meeko.xpl.Script;
	if (callback) script.onreadystatechange = function() { callback(script.readyState); };
	script.run(text);
}

Meeko.stuff.evalScript = function() {
	return eval(arguments[0]);
}

Meeko.stuff.createGlobal = function(name) {
	Meeko.stuff.execScript("var " + name + ";");
}

// NOTE cross-browser error catch-all
//if (window.addEventListener) window.addEventListener("error", function(event) { event.preventDefault(); }, false);
//else window.onerror = function(event) { return true; }; // FIXME

