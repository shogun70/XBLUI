<?xml version="1.0"?>
<?xpl-require href="../Javascript-1.6/Javascript.xhtml"?>
<?xpl-require href="../dom.xhtml"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<script type="text/javascript">
<![CDATA[

// FIXME refactor - this package has its fingers in everywhere and has back-doors for everything. Seriously yukky.

if (!this.Meeko) this.Meeko = {};

Meeko.events = (function() {

var privateKey = Math.random();

function copy(dst, src, fields, override) { // TODO maybe this should be a method on Object
	function _copy(name) {
		if (override || (dst.hasOwnProperty && !dst.hasOwnProperty(name)) || dst[name] == null) dst[name] = src[name]; // TODO is this correct?
	}
	if (fields && fields.length) {
		for (var n=fields.length, i=0; i<n; i++) {
			var name = fields[i];
			_copy(name);
		}
	}
	else {
		for (var name in src) _copy(name);
	}
	return dst;
}

function addBinding(target, bindingSpec) {
	var binding = new bindingSpec;
	binding.boundElement = target;
	for (var key in bindingSpec.prototype) {
		if (/^xbl/.test(key)) continue; // filter out xbl* methods
		(function(method) {
			target[method] = function() { return bindingSpec.prototype[method].apply(binding, arguments); }
		})(key);
	}
	if (binding.xblBindingAttached) binding.xblBindingAttached();
	return binding;
}

var w3cEventsTable = [
	{ type: "DOMActivate", bubbles: true, cancelable: true, module: "UIEvent" },
	{ type: "DOMFocusIn", bubbles: true, cancelable: false, module: "UIEvent" },
	{ type: "DOMFocusOut", bubbles: true, cancelable: false, module: "UIEvent" },
	{ type: "focus", bubbles: false, cancelable: false, module: "UIEvent" },
	{ type: "blur", bubbles: false, cancelable: false, module: "UIEvent" },
	{ type: "textInput", bubbles: true, cancelable: true, module: "TextEvent" },
	{ type: "click", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "dblclick", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "mousedown", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "mouseup", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "mouseover", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "mousemove", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "mouseout", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "keydown", bubbles: true, cancelable: true, module: "KeyboardEvent" },
	{ type: "keyup", bubbles: true, cancelable: true, module: "KeyboardEvent" },
	{ type: "mousemultiwheel", bubbles: true, cancelable: true, module: "MouseMultiWheelEvent" },
	{ type: "mousewheel", bubbles: true, cancelable: true, module: "MouseWheelEvent" },
	{ type: "DOMSubtreeModified", bubbles: true, cancelable: false, module: "MutationEvent" },
	{ type: "DOMNodeInserted", bubbles: true, cancelable: false, module: "MutationEvent" },
	{ type: "DOMNodeRemoved", bubbles: true, cancelable: false, module: "MutationEvent" },
	{ type: "DOMNodeRemovedFromDocument", bubbles: false, cancelable: false, module: "MutationEvent" },
	{ type: "DOMNodeInsertedIntoDocument", bubbles: false, cancelable: false, module: "MutationEvent" },
	{ type: "DOMAttrModified", bubbles: true, cancelable: false, module: "MutationEvent" },
	{ type: "DOMCharacterDataModified", bubbles: true, cancelable: false, module: "MutationEvent" },
	{ type: "DOMElementNameChanged", bubbles: true, cancelable: false, module: "MutationNameEvent" },
	{ type: "DOMAttributeNameChanged", bubbles: true, cancelable: false, module: "MutationNameEvent" },
	{ type: "load", bubbles: false, cancelable: false, module: "Event" },
	{ type: "unload", bubbles: false, cancelable: false, module: "Event" },
	{ type: "abort", bubbles: true, cancelable: false, module: "Event" },
	{ type: "error", bubbles: true, cancelable: false, module: "Event" },
	{ type: "select", bubbles: true, cancelable: false, module: "Event" },
	{ type: "change", bubbles: true, cancelable: false, module: "Event" },
	{ type: "submit", bubbles: true, cancelable: true, module: "Event" },
	{ type: "reset", bubbles: true, cancelable: true, module: "Event" },
	{ type: "resize", bubbles: true, cancelable: false, module: "UIEvent" },
	{ type: "scroll", bubbles: true, cancelable: false, module: "UIEvent" },
	{ type: "keypress", bubbles: true, cancelable: true, module: "KeyboardEvent" }, // non-standard
	{ type: "DOMContentLoaded", bubbles: true, cancelable: false, module: "Event" } // mozilla
];

var eventsByType = {};
for (var i=0, n=w3cEventsTable.length; i<n; i++) {
	var row = w3cEventsTable[i];
	var type = row["type"];
	eventsByType[type] = row;
}

var eventsByModule = {};
for (var i=0, n=w3cEventsTable.length; i<n; i++) {
	var row = w3cEventsTable[i];
	var type = row["type"];
	var module = row["module"];
	if (!eventsByModule[module]) eventsByModule[module] = {};
	eventsByModule[module][type] = row;
}


var w3cKeyIdentifiers = {
	"U+007F": 46, // Delete
	"U+0008": 8, // Backspace
	"U+001B": 27, // Escape
	Down: 40, End: 35, Enter: 13, Home: 36, Insert: 45,
	Left: 37, PageUp: 33, PageDown: 34, Right: 39, Up: 38,
	F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123
}

var keyIdentifiersByCode = {};
for (var keyId in w3cKeyIdentifiers) {
	var code = w3cKeyIdentifiers[keyId];
	keyIdentifiersByCode[code] = keyId;
}

var toHexDigit = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F" ];
for (var i=0; i<=15; i++) {
	for (var j=0; j<=15; j++) {
		var hex = "" + toHexDigit[i] + toHexDigit[j];
		var code = Number("0x"+hex);
		var keyId = "U+00" + hex;
		if (!keyIdentifiersByCode[code]) keyIdentifiersByCode[code] = keyId;		
	}
}

var safari2bouncyKeys;
if (/AppleWebKit/.test(navigator.userAgent) && Number(navigator.userAgent.match(/[0-9]+\.[0-9]+$/)) < 500) {
	safari2bouncyKeys = copy({}, w3cKeyIdentifiers);
	delete safari2bouncyKeys["U+0008"];	
}

var EventState = function() {}
// These states are set by the EventSystem, so won't be valid for general use
EventState.DEFAULT_PREVENTED = 0x01; 
EventState.PROPAGATION_STOPPED = 0x02;
EventState.FAKE_EVENT = 0x04;
EventState.COMPATIBILITY_EVENT = 0x08;

var WindowEventTarget = function() {}; // TODO implement by extending EventTarget

WindowEventTarget.prototype.xblBindingAttached = function() {
	this.listenerTable = {}; // lookup by this.listenerTable[type][Boolean(capture)][index]
	this.handleEvent = function(event) {
		var capture = (event.eventPhase == Event.CAPTURING_PHASE) ? 1 : 0;
		var table = this.listenerTable[event.type];
		if (!table) return;
		var listeners = table[capture];
		for (var n=listeners.length, i=0; i<n; i++) {
			var listener = listeners[i];
			if (listener.handleEvent) listener.handleEvent(event);
			else listener(event);
		}
	}
}

WindowEventTarget.prototype.addEventListener = function(type, listener, useCapture) {
	if (!this.listenerTable[type]) this.listenerTable[type] = [ [], [] ];
	var capture = (useCapture) ? 1 : 0;
	this.listenerTable[type][capture].push(listener);
}

WindowEventTarget.prototype.removeEventListener = function(type, listener, useCapture) {
	var capture = (useCapture) ? 1 : 0;
	var listeners;
	if (this.listenerTable[type]) listeners = this.listenerTable[type][capture];
	else return; // TODO logger.warn
	for (var i=listeners.length-1; i>=0; i--) {
		if (listeners[i] == listener) {
			listeners.splice(i, 1);
			break;
		}
	}
	// TODO warn on not found??
}

WindowEventTarget.prototype.dispatchEvent = function(event) {
	throw "dispatchEvent method not available on Window objects";
}

var EventSystem = function() {
	var eventSystem = this;
	this.registeredEvents = {};
	this.keyEventHistory = [];
	this.eventListener = function(event) {
		eventSystem.handleEvent(event);
	}
	if (window.addEventListener) {
		for (var type in eventsByType) {
			window.addEventListener(type, this.eventListener, true);
		}
	}

	this.windowEventTarget = addBinding(window, WindowEventTarget);
}


EventSystem.prototype.handleEvent = function(event) { // TODO refactor
	var keyEventFields = [ "type", "keyCode", "charCode", "keyIdentifier" ];
	var eventHandlersByType = {
		"keydown": function(event) {
			var keyId;
			if (event.keyIdentifier) keyId = event.keyIdentifier;
			else {
				keyId = keyIdentifiersByCode[event.keyCode];
				event.keyIdentifier = keyId;
			}
			var hist = this.keyEventHistory;
			var n = hist.length;
			var prev = (n) ? hist[n-1] : null;
			var repeat = 0;
			var delta = 1;
			if (safari2bouncyKeys && keyId in safari2bouncyKeys) { // TODO refactor
				repeat = -0.5;
				delta = 0.5;
			}
			if (prev && prev.type == "keydown") repeat = prev.repeat + delta;
			else if (prev && prev.type == "keypress") repeat = prev.repeat + delta;
			event.repeat = repeat;
			hist.push(copy({ type: "keydown", repeat: repeat }, event, keyEventFields));
			if (event.eventStatus & EventState.DEFAULT_PREVENTED) event.preventDefault(); // signal from keypress
			if (repeat % 1) { // ignore bouncy key registrations
				event.stopPropagation();
			}
			else {
				this.windowEventTarget.handleEvent(event);
			}		
		},
		"keypress": function(event) {
			var keyId;
			if (event.keyIdentifier) keyId = event.keyIdentifier;
			else {
				keyId = keyIdentifiersByCode[event.keyCode];
				event.keyIdentifier = keyId;
			}
			var hist = this.keyEventHistory;
			var n = hist.length;
			var prev = (n) ? hist[n-1] : null;
			var repeat = 0;
			var delta = 1;
			if (safari2bouncyKeys && keyId in safari2bouncyKeys) { // TODO refactor
				repeat = -0.5;
				delta = 0.5;
			}
			if (prev && prev.type == "keydown") repeat = prev.repeat;
			else if (prev && prev.type == "keypress") repeat = prev.repeat + delta;
			
			if (!(prev && prev.type == "keydown")) {
				event.stopPropagation();
				var newEvent;
				try { // FIXME does this work on all platforms?? In any case, it should be moved into document.createEvent, etc
					newEvent = document.createEvent("KeyboardEvent");
					if (newEvent.initKeyboardEvent) {
						newEvent.initKeyboardEvent("keydown", true, true, window, keyId, 0, "");						
					}
					else if (newEvent.initKeyEvent) {
						newEvent.initKeyEvent("keydown", true, true, window, false, false, false, false, event.keyCode, event.charCode);
					}
				}
				catch (error) {
					newEvent = document.createEvent("UIEvents");
					newEvent.initEvent("keydown", true, true);
					newEvent.keyIdentifier = keyId;
					newEvent.keyCode = event.keyCode;
				}
				newEvent.eventStatus = 0x01 | 0x08; // signal to handler to prevent default
				event.target.dispatchEvent(newEvent);
			}
			if (keyId in w3cKeyIdentifiers) {
				event.stopPropagation();
			}
			else {
				event.stopPropagation();
				var newEvent = document.createEvent("TextEvent");
				newEvent.initTextEvent("textInput", true, true, window, String.fromCharCode(event.keyCode));
				event.target.dispatchEvent(newEvent);
			}
			hist.push(copy({ type: "keypress", repeat: repeat }, event, keyEventFields));			
		},
		"textInput": function(event) {
			var hist = this.keyEventHistory;
			var n = hist.length;
			var prev = (n) ? hist[n-1] : null;
			if (prev.type == "keydown") {
				this.windowEventTarget.handleEvent(event);
				hist.push(copy({ type: "textInput" }, event, keyEventFields));
			}			
		},
		"keyup": function(event) {
			var keyId;
			if (event.keyIdentifier) keyId = event.keyIdentifier;
			else {
				keyId = keyIdentifiersByCode[event.keyCode];
				event.keyIdentifier = keyId;
			}
			var hist = this.keyEventHistory;
			var n = hist.length;
			var prev = hist[n-1];
			if (prev.type != "keyup" || prev.keyIdentifier != keyId) {
				hist.push(copy({ type: "keyup" }, event, keyEventFields));
				this.windowEventTarget.handleEvent(event);
			}			
		}
	}
	var handler = eventHandlersByType[event.type];
	if (handler) handler.call(this, event);
}

EventSystem.prototype.registerEvent = function(type) {
	if (this.registeredEvents[type]) return;
	var system = this;
	var systemListener = function(srcEvent) {
		system.dispatchEvent(srcEvent.srcElement, srcEvent);
	}

	var ieLookup = { // FIXME ensure all standard event properties are copied / created
		"DOMAttrModified": { type: "propertychange", bubbles: false, cancelable: false },
		"DOMActivate": { type: "activate", bubbles: true, cancelable: true },
		"DOMFocusIn": { type: "focusin", bubbles: true, cancelable: false },
		"DOMFocusOut": { type: "focusout", bubbles: true, cancelable: false },
		"keydown": function() {
			document.attachEvent("onkeydown", function(srcEvent) {
				var event = document.createEvent("UIEvents");
				event.initEvent("keydown", true, true);
				event.keyCode = srcEvent.keyCode;
				event.keyIdentifier = keyIdentifiersByCode[srcEvent.keyCode];
				event.returnValue = system.dispatchEvent(srcEvent.srcElement, event);
				return event.returnValue;
			});
		},
		"keyup": function() {
			document.attachEvent("onkeyup", function(srcEvent) {
				var event = document.createEvent("UIEvents");
				event.initEvent("keyup", true, true);
				event.keyCode = srcEvent.keyCode;
				event.keyIdentifier = keyIdentifiersByCode[srcEvent.keyCode];
				event.returnValue = system.dispatchEvent(srcEvent.srcElement, event);
				return event.returnValue;
			});
		},
		"textInput": function() {
			window.attachEvent("onkeypress", function(srcEvent) {
				var event = document.createEvent("UIEvents");
				event.initEvent("textInput", true, true);
				event.data = String.fromCharCode(srcEvent.keyCode);
				srcEvent.returnValue = system.dispatchEvent(srcEvent.srcElement, event);
			});
		},
		"focus": function() {
			window.attachEvent("onfocusin", function(srcEvent) {
				var event = document.createEvent("UIEvents");
				event.initEvent("focus", false, false);
				srcEvent.returnValue = system.dispatchEvent(srcEvent.srcElement, event);
			});
		},
		"blur": function() {
			window.attachEvent("onfocusout", function(srcEvent) {
				var event = document.createEvent("UIEvents");
				event.initEvent("blur", false, false);
				srcEvent.returnValue = system.dispatchEvent(srcEvent.srcElement, event);
			});
		},
		"click": function() {
			document.attachEvent("onclick", function(srcEvent) {
				var event = document.createEvent("UIEvents");
				event.initEvent("click", true, true);
				event.button = ([ null, 0, 2, null, 1 ])[srcEvent.button];
				event.detail = 1;
				srcEvent.returnValue = system.dispatchEvent(srcEvent.srcElement, event);
			});
		},
		"dblclick": function() {
			document.attachEvent("ondblclick", function(srcEvent) {
				var event = document.createEvent("UIEvents");
				event.initEvent("dblclick", true, true);
				event.button = ([ null, 0, 2, null, 1 ])[srcEvent.button];
				event.detail = 2;
				srcEvent.returnValue = system.dispatchEvent(srcEvent.srcElement, event);
			});
		}
	}

	var rego = ieLookup[type] || { type: type, bubbles: true, cancelable: true};

	if (typeof rego == "function") rego();
	else document.attachEvent("on"+rego.type, systemListener);
	this.registeredEvents[type] = true;
}

EventSystem.prototype.dispatchEvent = function(target, event) {
	event.target = target;
	var path = [];
	var current = target;
	if (target != window) {
		for (current=target; current!=document; current=current.parentNode) { // FIXME will fail for document fragments, etc
			path.push(current);
		}
		path.push(document);
	}
	path.push(window);

	event.eventPhase = Event.CAPTURING_PHASE;
	for (var n=path.length, i=n-1; i>0; i--) {
		current = path[i];
		event.currentTarget = current;
		if (current._eventTarget) current._eventTarget.handleEvent(event);
		if (event.cancelBubble) return event.returnValue; 
	}

	current = path[0];
	event.eventPhase = Event.AT_TARGET;
	event.currentTarget = current;
	if (current._eventTarget) current._eventTarget.handleEvent(event);

	if (!event.bubbles) return event.returnValue;
	if (event.cancelBubble) return event.returnValue;

	event.eventPhase = Event.BUBBLING_PHASE;
	for (var n=path.length, i=1; i<n; i++) {
		current = path[i];
		event.currentTarget = current;
		if (current._eventTarget) current._eventTarget.handleEvent(event);
		if (event.cancelBubble) return event.returnValue; 
	}
	
	return event.returnValue;	
}

var eventSystem = addBinding(window, EventSystem);

var Event = function(key) {
	if (key != privateKey) throw "Event is not a constructor";
};
Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;
Event.prototype.initEvent = function(type, bubbles, cancelable) {
	this.type = type;
	this.bubbles = Boolean(bubbles);
	this.cancelable = Boolean(cancelable);
	this.eventStatus = 0;
	this.timeStamp = Number(new Date);
}

Event.prototype.preventDefault = function() { this.eventStatus |= EventState.DEFAULT_PREVENTED; }
Event.prototype.stopPropagation = function() { this.eventStatus |= EventState.PROPAGATION_STOPPED; }


var CustomEvent = function(key) {
	if (key != privateKey) throw "CustomEvent is not a constructor";
};
CustomEvent.prototype = new Event(privateKey);
CustomEvent.prototype.initCustomEvent = function(type, bubbles, cancelable, detail) {
	this.type = type;
	this.bubbles = Boolean(bubbles);
	this.cancelable = Boolean(cancelable);
	this.detail = detail;
	this.eventStatus = 0;
	this.timeStamp = Number(new Date);
}

var UIEvent = function(key) {
	if (key != privateKey) throw "UIEvent is not a constructor";
};
UIEvent.prototype = new Event(privateKey);
UIEvent.prototype.initUIEvent = function(type, bubbles, cancelable, view, detail) {
	this.type = type;
	this.bubbles = Boolean(bubbles);
	this.cancelable = Boolean(cancelable);
	this.view = view;
	this.detail = detail;
	this.eventStatus = 0;
	this.timeStamp = Number(new Date);
}

var KeyboardEvent = function(key) {
	if (key != privateKey) throw "KeyboardEvent is not a constructor";
};
KeyboardEvent.prototype = new UIEvent(privateKey);
KeyboardEvent.DOM_KEY_LOCATION_STANDARD = 0x00;
KeyboardEvent.DOM_KEY_LOCATION_LEFT = 0x01;
KeyboardEvent.DOM_KEY_LOCATION_RIGHT = 0x02;
KeyboardEvent.DOM_KEY_LOCATION_NUMPAD = 0x03;
KeyboardEvent.prototype.initKeyboardEvent = function(type, bubbles, cancelable, view, keyIdentifier, keyLocation, modifierList) {
	this.type = type;
	this.bubbles = Boolean(bubbles);
	this.cancelable = Boolean(cancelable);
	this.view = view;
	this.keyIdentifier = keyIdentifier;
	this.keyLocation = keyLocation;
	var modifiers = modifierList.split(" ");
	for (var n=modifiers.length, i=0; i<n; i++) { // TODO other modifiers
		switch (modifiers[i]) {
			case "Alt": this.altKey = true; break;
			case "Control": this.ctrlKey = true; break;
			case "Meta": this.metaKey = true; break;
			case "Shift": this.shiftKey = true; break;
		}
	}
	// TODO getModifierState()
	this.eventStatus = 0;
	this.timeStamp = Number(new Date);
}

var MouseEvent = function(key) {
	if (key != privateKey) throw "MouseEvent is not a constructor";
};
MouseEvent.prototype = new UIEvent(privateKey);
MouseEvent.prototype.initMouseEvent = function() {
	var xplParams = [ "type", "bubbles", "cancelable", "view", "detail", "screenX", "screenY", "clientX", "clientY", "ctrlKey", "altKey", "shiftKey", "metaKey", "button", "relatedTarget" ]
	var n = xplParams.length;
	if (arguments.length < n) throw "Improper argument list in call to initMouseEvent"; // FIXME
	for (var n=xplParams.length, i=0; i<n; i++) {
		var name = xplParams[i];
		this[name] = arguments[i];
	}
	this.timeStamp = Number(new Date);
}



var MutationEvent = function(key) {
	if (key != privateKey) throw "MouseEvent is not a constructor";
};
MutationEvent.MODIFICATION = 1;
MutationEvent.ADDITION = 2;
MutationEvent.REMOVAL = 3;
MutationEvent.prototype = new Event(privateKey);
MutationEvent.prototype.initMutationEvent = function() {
	var xplParams = [ "type", "bubbles", "cancelable", "relatedNode", "prevValue", "newValue", "attrName", "attrChange" ]
	var n = xplParams.length;
	if (arguments.length < n) throw "Improper argument list in call to initMutationEvent"; // FIXME
	for (var n=xplParams.length, i=0; i<n; i++) {
		var name = xplParams[i];
		this[name] = arguments[i];
	}
	this.eventStatus = 0;
	this.timeStamp = Number(new Date);
}


var eventModuleMap = {
	"HTMLEvents": "Event",
	"UIEvents": "UIEvent",
	"MouseEvents": "MouseEvent",
	"MutationEvents": "MutationEvent"
}


var DocumentEvent = function() {}
if (document.createEventObject) {

var eventTemplates = {
	Event: new Event(privateKey),
	CustomEvent: new CustomEvent(privateKey),
	UIEvent: new UIEvent(privateKey),
	KeyboardEvent: new KeyboardEvent(privateKey),
	MouseEvent: new MouseEvent(privateKey),
	MutationEvent: new MutationEvent(privateKey)	
}

DocumentEvent.prototype.createEvent = function(module) {
	var dom3Module = eventModuleMap[module] || module;
	var event = document.createEventObject();
	var tmp = eventTemplates[dom3Module];
	copy(event, tmp);
	event.preventDefault = function() { this.returnValue = false; }
	event.stopPropagation = function() { this.cancelBubble = true; }
	return event;
}

var documentEvent = addBinding(document, DocumentEvent);

}

var EventTarget = function(element) { // FIXME interface removal on window.onunload
	// TODO Meeko.Namespace.enhance(_eventTarget, element);
	element._eventTarget = this;
	for (var slot in this) {
		if ("function" == typeof this[slot]) (function(iface, method) {
			element[method] = function() { iface[method].apply(iface, arguments); };
		})(this, slot);
	}
	this.boundElement = element;
	this.listenerTable = {}; // lookup by this.listenerTable[type][Boolean(capture)][index]
	this.handleEvent = function(event) {
		var capture = (event.eventPhase == Event.CAPTURING_PHASE) ? 1 : 0;
		var table = this.listenerTable[event.type];
		if (!table) return;
		var listeners = table[capture];
		for (var n=listeners.length, i=0; i<n; i++) {
			var listener = listeners[i];
			if (listener.handleEvent) listener.handleEvent(event);
			else listener(event);
		}
	}
}

EventTarget.prototype.addEventListener = function(type, listener, useCapture) {
	if (!this.listenerTable[type]) this.listenerTable[type] = [ [], [] ];
	var capture = (useCapture) ? 1 : 0;
	this.listenerTable[type][capture].push(listener);
	eventSystem.registerEvent(type);
}

EventTarget.prototype.removeEventListener = function(type, listener, useCapture) {
	var capture = (useCapture) ? 1 : 0;
	var listeners = this.listenerTable[type][capture];
	for (var i=listeners.length-1; i>=0; i--) {
		if (listeners[i] == listener) {
			listeners.splice(i, 1);
			break;
		}
	}
	// TODO warn on not found??
}

EventTarget.prototype.dispatchEvent = function(event) {
	var element = this.boundElement;
	try { return element.fireEvent("on" + event.type, event); }
	catch (error) { return eventSystem.dispatchEvent(element, event); }
}		

if (!document.addEventListener && document.attachEvent) {

var documentEventTarget = new EventTarget(document);

}

Meeko.stuff.eventSystem = eventSystem; // FIXME back-door to virtually everything

return {
	Event: Event,
	EventTarget: EventTarget,
	DocumentEvent: DocumentEvent
}

})();
]]>
</script>
</head>
</html>