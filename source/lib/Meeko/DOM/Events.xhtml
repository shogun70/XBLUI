<?xml version="1.0"?>
<?xpl-require href="../Javascript-1.6/Javascript.xhtml"?>
<?xpl-require href="../DOM/System.xhtml"?>
<?xpl-require href="../DOM/Core.xhtml"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<script type="text/javascript">
<![CDATA[

// FIXME refactor - this package has its fingers in everywhere and has back-doors for everything. Seriously yukky.
// FIXME confirm that preventDefault & stopPropagation actually work

Meeko.stuff.xplSystem.createNamespace("Meeko.DOM.Events");
Meeko.DOM.Events = (function() {

var privateKey = Math.random();

var w3cEventsTable = [
	{ type: "DOMActivate", bubbles: true, cancelable: true, module: "UIEvent" },
	{ type: "DOMFocusIn", bubbles: true, cancelable: false, module: "UIEvent" },
	{ type: "DOMFocusOut", bubbles: true, cancelable: false, module: "UIEvent" },
	{ type: "focus", bubbles: false, cancelable: false, module: "UIEvent" },
	{ type: "blur", bubbles: false, cancelable: false, module: "UIEvent" },
	{ type: "textInput", bubbles: true, cancelable: true, module: "TextEvent" },
	{ type: "click", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "dblclick", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "mousedown", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "mouseup", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "mouseover", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "mousemove", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "mouseout", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "keydown", bubbles: true, cancelable: true, module: "KeyboardEvent" },
	{ type: "keyup", bubbles: true, cancelable: true, module: "KeyboardEvent" },
	{ type: "mousemultiwheel", bubbles: true, cancelable: true, module: "MouseMultiWheelEvent" },
	{ type: "mousewheel", bubbles: true, cancelable: true, module: "MouseWheelEvent" },
	{ type: "DOMSubtreeModified", bubbles: true, cancelable: false, module: "MutationEvent" },
	{ type: "DOMNodeInserted", bubbles: true, cancelable: false, module: "MutationEvent" },
	{ type: "DOMNodeRemoved", bubbles: true, cancelable: false, module: "MutationEvent" },
	{ type: "DOMNodeRemovedFromDocument", bubbles: false, cancelable: false, module: "MutationEvent" },
	{ type: "DOMNodeInsertedIntoDocument", bubbles: false, cancelable: false, module: "MutationEvent" },
	{ type: "DOMAttrModified", bubbles: true, cancelable: false, module: "MutationEvent" },
	{ type: "DOMCharacterDataModified", bubbles: true, cancelable: false, module: "MutationEvent" },
	{ type: "DOMElementNameChanged", bubbles: true, cancelable: false, module: "MutationNameEvent" },
	{ type: "DOMAttributeNameChanged", bubbles: true, cancelable: false, module: "MutationNameEvent" },
	{ type: "load", bubbles: false, cancelable: false, module: "Event" },
	{ type: "unload", bubbles: false, cancelable: false, module: "Event" },
	{ type: "abort", bubbles: true, cancelable: false, module: "Event" },
	{ type: "error", bubbles: true, cancelable: false, module: "Event" },
	{ type: "select", bubbles: true, cancelable: false, module: "Event" },
	{ type: "change", bubbles: true, cancelable: false, module: "Event" },
	{ type: "submit", bubbles: true, cancelable: true, module: "Event" },
	{ type: "reset", bubbles: true, cancelable: true, module: "Event" },
	{ type: "resize", bubbles: true, cancelable: false, module: "UIEvent" },
	{ type: "scroll", bubbles: true, cancelable: false, module: "UIEvent" },
	{ type: "keypress", bubbles: true, cancelable: true, module: "KeyboardEvent" }, // non-standard
	{ type: "DOMContentLoaded", bubbles: true, cancelable: false, module: "Event" } // mozilla
];

var eventsByType = {};
for (var i=0, n=w3cEventsTable.length; i<n; i++) {
	var row = w3cEventsTable[i];
	var type = row["type"];
	eventsByType[type] = row;
}

var eventsByModule = {};
for (var i=0, n=w3cEventsTable.length; i<n; i++) {
	var row = w3cEventsTable[i];
	var type = row["type"];
	var module = row["module"];
	if (!eventsByModule[module]) eventsByModule[module] = {};
	eventsByModule[module][type] = row;
}


var w3cKeyIdentifiers = {
	"U+007F": 46, // Delete
	"U+0008": 8, // Backspace
	"U+001B": 27, // Escape
	Down: 40, End: 35, Enter: 13, Home: 36, Insert: 45,
	Left: 37, PageUp: 33, PageDown: 34, Right: 39, Up: 38,
	F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123
}

var keyIdentifiersByCode = {};
for (var keyId in w3cKeyIdentifiers) {
	var code = w3cKeyIdentifiers[keyId];
	keyIdentifiersByCode[code] = keyId;
}

var toHexDigit = "0123456789ABCDEF".split(/\s*/);
for (var i=0; i<=15; i++) {
	for (var j=0; j<=15; j++) {
		var hex = "" + toHexDigit[i] + toHexDigit[j];
		var code = Number("0x"+hex);
		var keyId = "U+00" + hex;
		if (!keyIdentifiersByCode[code]) keyIdentifiersByCode[code] = keyId;		
	}
}

var safari2bouncyKeys; 
if (/AppleWebKit/.test(navigator.userAgent) && Number(navigator.userAgent.match(/[0-9]+\.[0-9]+$/)) < 500) { // FIXME is this correct?
	safari2bouncyKeys = Object.copy({}, w3cKeyIdentifiers);
	delete safari2bouncyKeys["U+0008"];	
}

var EventState = function() {}
// These states are set by the EventSystem, so won't be valid for general use
EventState.DEFAULT_PREVENTED = 0x01; 
EventState.PROPAGATION_STOPPED = 0x02;
EventState.FAKE_EVENT = 0x04;
EventState.COMPATIBILITY_EVENT = 0x08;

var EventSystem = function() {
	var eventSystem = this;
	this.registeredEvents = {};
	this.keyEventHistory = [];
	this.eventListener = function(event) {
		eventSystem.handleEvent(event);
	}
	if (window.addEventListener) {
		for (var type in eventsByType) {
			window.addEventListener(type, this.eventListener, true);
		}
	}

}

var eventSystem = new EventSystem;

EventSystem.prototype.handleEvent = function(event) { // TODO refactor
	var keyEventFields = [ "type", "keyCode", "charCode", "keyIdentifier" ];
	var eventHandlersByType = {
		"DOMNodeInserted": function() {},
		"DOMNodeRemoved": function() {},
		"DOMSubtreeModified": function() {},
		"error": function() {},
		"resize": function() {},
		"DOMContentLoaded": function(event) {
			if (event.eventStatus & EventState.FAKE_EVENT) { // only let fake events thru
				var eventTarget = EventTarget(event.currentTarget);
				if (eventTarget) eventTarget.handleEvent(event);
				logger.debug("Compat DOMContentLoaded event received" + (eventTarget ? " and forwarded" : ""));
			}
			else {
				logger.debug("Browser DOMContentLoaded event received.");
				event.stopPropagation();				
			}
			return false;
		},
		"load": function(event) {
			if (event.eventStatus & EventState.FAKE_EVENT) { // only let fake events thru
				var eventTarget = EventTarget(event.currentTarget);
				if (eventTarget) eventTarget.handleEvent(event);
				logger.debug("Compat load event received" + (eventTarget ? " and forwarded" : ""));
			}
			else {
				logger.debug("Browser load event received.");
				event.stopPropagation();				
			}
			return false;
		},
		"keydown": function(event) {
			var keyId;
			if (event.keyIdentifier) keyId = event.keyIdentifier;
			else {
				keyId = keyIdentifiersByCode[event.keyCode];
				event.keyIdentifier = keyId;
			}
			var hist = this.keyEventHistory;
			var n = hist.length;
			var prev = (n) ? hist[n-1] : null;
			var repeat = 0;
			var delta = 1;
			if (safari2bouncyKeys && keyId in safari2bouncyKeys) { // TODO refactor
				repeat = -0.5;
				delta = 0.5;
			}
			if (prev && prev.type == "keydown") repeat = prev.repeat + delta;
			else if (prev && prev.type == "keypress") repeat = prev.repeat + delta;
			event.repeat = repeat;
			hist.push(Object.copy({ type: "keydown", repeat: repeat }, event, keyEventFields));
			if (event.eventStatus & EventState.DEFAULT_PREVENTED) event.preventDefault(); // signal from keypress
			if (repeat % 1) { // ignore bouncy key registrations
				event.stopPropagation();
			}
			else {
				EventTarget(window).handleEvent(event);
			}		
		},
		"keypress": function(event) {
			var keyId;
			if (event.keyIdentifier) keyId = event.keyIdentifier;
			else {
				keyId = keyIdentifiersByCode[event.keyCode];
				event.keyIdentifier = keyId;
			}
			var hist = this.keyEventHistory;
			var n = hist.length;
			var prev = (n) ? hist[n-1] : null;
			var repeat = 0;
			var delta = 1;
			if (safari2bouncyKeys && keyId in safari2bouncyKeys) { // TODO refactor
				repeat = -0.5;
				delta = 0.5;
			}
			if (prev && prev.type == "keydown") repeat = prev.repeat;
			else if (prev && prev.type == "keypress") repeat = prev.repeat + delta;
			
			if (!(prev && prev.type == "keydown")) {
				event.stopPropagation();
				var newEvent;
				try { // FIXME does this work on all platforms?? In any case, it should be moved into document.createEvent, etc
					newEvent = document.createEvent("KeyboardEvent");
					if (newEvent.initKeyboardEvent) {
						newEvent.initKeyboardEvent("keydown", true, true, window, keyId, 0, "");						
					}
					else if (newEvent.initKeyEvent) {
						newEvent.initKeyEvent("keydown", true, true, window, false, false, false, false, event.keyCode, event.charCode);
					}
				}
				catch (error) {
					newEvent = document.createEvent("UIEvent");
					newEvent.initEvent("keydown", true, true);
					newEvent.keyIdentifier = keyId;
					newEvent.keyCode = event.keyCode;
				}
				newEvent.eventStatus = 0x01 | 0x08; // signal to handler to prevent default
				event.target.dispatchEvent(newEvent);
			}
			if (keyId in w3cKeyIdentifiers) {
				event.stopPropagation();
			}
			else {
				event.stopPropagation();
				var newEvent = document.createEvent("TextEvent");
				newEvent.initTextEvent("textInput", true, true, window, String.fromCharCode(event.keyCode));
				event.target.dispatchEvent(newEvent);
			}
			hist.push(Object.copy({ type: "keypress", repeat: repeat }, event, keyEventFields));			
		},
		"textInput": function(event) {
			var hist = this.keyEventHistory;
			var n = hist.length;
			var prev = (n) ? hist[n-1] : null;
			if (prev && prev.type == "keydown") {
				EventTarget(window).handleEvent(event);
				hist.push(Object.copy({ type: "textInput" }, event, keyEventFields));
			}			
		},
		"keyup": function(event) {
			var keyId;
			if (event.keyIdentifier) keyId = event.keyIdentifier;
			else {
				keyId = keyIdentifiersByCode[event.keyCode];
				event.keyIdentifier = keyId;
			}
			var hist = this.keyEventHistory;
			var n = hist.length;
			var prev = hist[n-1];
			if (prev && (prev.type != "keyup" || prev.keyIdentifier != keyId)) {
				hist.push(Object.copy({ type: "keyup" }, event, keyEventFields));
				EventTarget(window).handleEvent(event);
			}			
		}
	}
	var handler = eventHandlersByType[event.type] || function(event) { EventTarget(window).handleEvent(event); };
	if (handler) handler.call(this, event);
}

EventSystem.prototype.registerEvent = function(type) {
	if (this.registeredEvents[type]) return;
	var systemListener = function(srcEvent) { // FIXME not sending w3c event
		var event = document.createEvent("Event");
		event.initEvent(srcEvent.type, srcEvent.bubbles, srcEvent.cancelable);
		Object.copy(event, srcEvent);
		eventSystem.dispatchEvent(srcEvent.srcElement, event);
		return event.returnValue;
	}

	var ieLookup = { // FIXME ensure all standard event properties are copied / created
		"DOMAttrModified": { type: "propertychange", bubbles: false, cancelable: false },
		"DOMActivate": { type: "activate", bubbles: true, cancelable: true },
		"DOMFocusIn": { type: "focusin", bubbles: true, cancelable: false },
		"DOMFocusOut": { type: "focusout", bubbles: true, cancelable: false },
		"keydown": function() {
			document.attachEvent("onkeydown", function(srcEvent) {
				var event = document.createEvent("UIEvent");
				event.initEvent("keydown", true, true);
				event.keyCode = srcEvent.keyCode;
				event.keyIdentifier = keyIdentifiersByCode[srcEvent.keyCode];
				event.returnValue = eventSystem.dispatchEvent(srcEvent.srcElement, event);
				return event.returnValue;
			});
		},
		"keyup": function() {
			document.attachEvent("onkeyup", function(srcEvent) {
				var event = document.createEvent("UIEvent");
				event.initEvent("keyup", true, true);
				event.keyCode = srcEvent.keyCode;
				event.keyIdentifier = keyIdentifiersByCode[srcEvent.keyCode];
				event.returnValue = eventSystem.dispatchEvent(srcEvent.srcElement, event);
				return event.returnValue;
			});
		},
		"textInput": function() {
			document.attachEvent("onkeypress", function(srcEvent) {
				var event = document.createEvent("UIEvent");
				event.initEvent("textInput", true, true);
				event.data = String.fromCharCode(srcEvent.keyCode);
				srcEvent.returnValue = eventSystem.dispatchEvent(srcEvent.srcElement, event);
			});
		},
		"focus": function() {
			document.attachEvent("onfocusin", function(srcEvent) {
				var event = document.createEvent("UIEvent");
				event.initEvent("focus", false, false);
				srcEvent.returnValue = eventSystem.dispatchEvent(srcEvent.srcElement, event);
			});
		},
		"blur": function() {
			document.attachEvent("onfocusout", function(srcEvent) {
				var event = document.createEvent("UIEvent");
				event.initEvent("blur", false, false);
				srcEvent.returnValue = eventSystem.dispatchEvent(srcEvent.srcElement, event);
			});
		},
		"mouseover": function() {
			document.attachEvent("onmouseover", function(srcEvent) {
				var event = document.createEvent("UIEvent");
				event.initEvent("mouseover", true, true);
				event.relatedTarget = srcEvent.fromElement;
				srcEvent.returnValue = eventSystem.dispatchEvent(srcEvent.srcElement, event);
				event.relatedTarget = null;
			});
		},
		"mouseout": function() {
			document.attachEvent("onmouseout", function(srcEvent) {
				var event = document.createEvent("UIEvent");
				event.initEvent("mouseout", true, true);
				event.relatedTarget = srcEvent.toElement;
				srcEvent.returnValue = eventSystem.dispatchEvent(srcEvent.srcElement, event);
				event.relatedTarget = null;
			});
		},
		"click": function() {
			document.attachEvent("onclick", function(srcEvent) {
				var event = document.createEvent("UIEvent");
				event.initEvent("click", true, true);
				event.button = ([ null, 0, 2, null, 1 ])[srcEvent.button];
				event.detail = 1;
				srcEvent.returnValue = eventSystem.dispatchEvent(srcEvent.srcElement, event);
			});
		},
		"dblclick": function() {
			document.attachEvent("ondblclick", function(srcEvent) {
				var event = document.createEvent("UIEvent");
				event.initEvent("dblclick", true, true);
				event.button = ([ null, 0, 2, null, 1 ])[srcEvent.button];
				event.detail = 2;
				srcEvent.returnValue = eventSystem.dispatchEvent(srcEvent.srcElement, event);
			});
		}
	}

	var rego = ieLookup[type] || { type: type, bubbles: true, cancelable: true};

	if (typeof rego == "function") rego();
	else document.attachEvent("on"+rego.type, systemListener);
	this.registeredEvents[type] = true;
}

EventSystem.prototype.dispatchEvent = function(target, event) {
	this._dispatchEvent(target, event);
	event.currentTarget = null;
	event.target = null;
	return event.returnValue;
}

EventSystem.prototype._dispatchEvent = function(target, event) {
	event.target = target;
	var path = [];
	var current = target;
	if (target != window) {
		for (current=target; current!=document; current=current.parentNode) { // FIXME will fail for document fragments, etc
			path.push(current);
		}
		path.push(document);
	}
	path.push(window);

	function dispatch(current, event) {
		event.currentTarget = current;
		var eventTarget = EventTarget(current);
		if (eventTarget) eventTarget.handleEvent(event);		
	}
	
	event.eventPhase = Event.CAPTURING_PHASE;
	
	for (var n=path.length, i=n-1; i>0; i--) {
		dispatch(path[i], event);
		if (event.cancelBubble) return event.returnValue; 
	}

	event.eventPhase = Event.AT_TARGET;
	dispatch(path[0], event);
	if (event.cancelBubble) return event.returnValue;

	if (!event.bubbles) return event.returnValue;

	event.eventPhase = Event.BUBBLING_PHASE;
	for (var n=path.length, i=1; i<n; i++) {
		dispatch(path[i], event);
		if (event.cancelBubble) return event.returnValue; 
	}
	
	return event.returnValue;	
}

var Event = function(key) {
	if (key != privateKey) throw "Event is not a constructor";
};
Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;
Event.prototype.initEvent = function(type, bubbles, cancelable) { // TODO check that event.type is appropriate for event-module
	this.eventStatus = 0;
	this.timeStamp = Number(new Date);
	this.type = type;
	this.bubbles = Boolean(bubbles);
	this.cancelable = Boolean(cancelable);
}

Event.prototype.preventDefault = function() { this.eventStatus |= EventState.DEFAULT_PREVENTED; }
Event.prototype.stopPropagation = function() { this.eventStatus |= EventState.PROPAGATION_STOPPED; }


var CustomEvent = function(key) {
	if (key != privateKey) throw "CustomEvent is not a constructor";
};
CustomEvent.prototype = new Event(privateKey);
CustomEvent.prototype.initCustomEvent = function(type, bubbles, cancelable, detail) {
	this.initEvent(type, bubbles, cancelable);
	this.detail = detail;
}

var UIEvent = function(key) {
	if (key != privateKey) throw "UIEvent is not a constructor";
};
UIEvent.prototype = new Event(privateKey);
UIEvent.prototype.initUIEvent = function(type, bubbles, cancelable, view, detail) {
	this.initEvent(type, bubbles, cancelable);
	this.view = view;
	this.detail = detail;
}

var TextEvent = function(key) {
	if (key != privateKey) throw "TextEvent is not a constructor";
};
TextEvent.prototype = new UIEvent(privateKey);
TextEvent.DOM_KEY_LOCATION_STANDARD = 0x00;
TextEvent.DOM_KEY_LOCATION_LEFT = 0x01;
TextEvent.DOM_KEY_LOCATION_RIGHT = 0x02;
TextEvent.DOM_KEY_LOCATION_NUMPAD = 0x03;
TextEvent.prototype.initTextEvent = function(type, bubbles, cancelable, view, data) {
	this.initUIEvent(type, bubbles, cancelable, view, 0);
	this.data = data;
}

var KeyboardEvent = function(key) {
	if (key != privateKey) throw "KeyboardEvent is not a constructor";
};
KeyboardEvent.prototype = new UIEvent(privateKey);
KeyboardEvent.DOM_KEY_LOCATION_STANDARD = 0x00;
KeyboardEvent.DOM_KEY_LOCATION_LEFT = 0x01;
KeyboardEvent.DOM_KEY_LOCATION_RIGHT = 0x02;
KeyboardEvent.DOM_KEY_LOCATION_NUMPAD = 0x03;
KeyboardEvent.prototype.initKeyboardEvent = function(type, bubbles, cancelable, view, keyIdentifier, keyLocation, modifierList) {
	this.initUIEvent(type, bubbles, cancelable, view, 0);
	this.keyIdentifier = keyIdentifier;
	this.keyLocation = keyLocation;
	this._modifiers = modifierList.split(" ");
	for (var n=this._modifiers.length, i=0; i<n; i++) {
		switch (this._modifiers[i]) {
			case "Alt": this.altKey = true; break;
			case "Control": this.ctrlKey = true; break;
			case "Meta": this.metaKey = true; break;
			case "Shift": this.shiftKey = true; break;
		}
	}
}
KeyboardEvent.prototype.getModifierState = function(keyIdentifier) {
	for (var n=this._modifiers.length, i=0; i<n; i++) {
		if (keyIdentifier == this._modifiers[i]) return true;
	}
	return false;
}

var MouseEvent = function(key) {
	if (key != privateKey) throw "MouseEvent is not a constructor";
};
MouseEvent.prototype = new UIEvent(privateKey);
MouseEvent.prototype.initMouseEvent = function(type, bubbles, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget) {
	var xplParams = [ "type", "bubbles", "cancelable", "view", "detail", "screenX", "screenY", "clientX", "clientY", "ctrlKey", "altKey", "shiftKey", "metaKey", "button", "relatedTarget" ]
	var n = xplParams.length;
	if (arguments.length < n) throw "Improper argument list in call to initMouseEvent"; // FIXME
	this.initUIEvent(type, bubbles, cancelable, view, detail);
	for (var i=5; i<n; i++) {
		var name = xplParams[i];
		this[name] = arguments[i];
	}
}



var MutationEvent = function(key) {
	if (key != privateKey) throw "MutationEvent is not a constructor";
};
MutationEvent.MODIFICATION = 1;
MutationEvent.ADDITION = 2;
MutationEvent.REMOVAL = 3;
MutationEvent.prototype = new Event(privateKey);
MutationEvent.prototype.initMutationEvent = function(type, bubbles, cancelable) {
	var xplParams = [ "type", "bubbles", "cancelable", "relatedNode", "prevValue", "newValue", "attrName", "attrChange" ]
	var n = xplParams.length;
	// if (arguments.length < n) throw "Improper argument list in call to initMutationEvent"; // FIXME
	this.initEvent(type, bubbles, cancelable);
	for (var i=3; i<n; i++) {
		var name = xplParams[i];
		this[name] = arguments[i];
	}
}


var eventTemplates = {
	Event: new Event(privateKey),
	CustomEvent: new CustomEvent(privateKey),
	UIEvent: new UIEvent(privateKey),
	TextEvent: new TextEvent(privateKey),
	KeyboardEvent: new KeyboardEvent(privateKey),
	MouseEvent: new MouseEvent(privateKey),
	MutationEvent: new MutationEvent(privateKey)	
}

var eventModuleMap = {
	"Events": "Event",
	"HTMLEvents": "Event",
	"UIEvents": "UIEvent",
	"MouseEvents": "MouseEvent",
	"MutationEvents": "MutationEvent"
}


var DocumentEvent = function() {} // TODO Document.addImplementation(DocumentEvent);
if (document.createEvent) {{ // Upgrade if less than DOM3

DocumentEvent.prototype.createEvent = function(module) {
	var dom3Module = eventModuleMap[module] || module;
	var tmp = eventTemplates[dom3Module];
	if (!tmp) throw "Invalid event module: " + module;
	var event;
	var modules = [ dom3Module, module, "Event", "HTMLEvents" ];
	for (var n=modules.length, i=0; i<n; i++) {
		try { event = document._createEvent(modules[i]); } catch (error) { }
		if (event) break;
	}
	if (!event) throw "Could not create event in " + module;
	Object.copy(event, tmp);
	event.eventStatus |= EventState.FAKE_EVENT;
	event.preventDefault = function() { Event.prototype.preventDefault.call(this); window.Event.prototype.preventDefault.call(this); }
	event.stopPropagation = function() { Event.prototype.stopPropagation.call(this); window.Event.prototype.stopPropagation.call(this); }
	return event;
}

var fail = false;
forEach (eventsByModule, function(dummy, module) {
	try {
		var event = document.createEvent(module);
		if (!event["init"+module]) fail = true;
	}
	catch (error) { fail = true; }
})
if (fail) {
	document._createEvent = document.createEvent;
	document.createEvent = DocumentEvent.prototype.createEvent;
}

}}

else if (document.createEventObject) {{

DocumentEvent.prototype.createEvent = function(module) {
	var dom3Module = eventModuleMap[module] || module;
	var tmp = eventTemplates[dom3Module];
	if (!tmp) throw "Invalid event module: " + module;
	var event = document.createEventObject();
	Object.copy(event, tmp);
	event.eventStatus |= EventState.FAKE_EVENT;
	event.preventDefault = function() { Event.prototype.preventDefault.call(this); this.returnValue = false; }
	event.stopPropagation = function() { Event.prototype.stopPropagation.call(this); this.cancelBubble = true; }
	return event;
}

document.createEvent = DocumentEvent.prototype.createEvent;

}}


var GenericEventTarget = function(target, eventSystem) {
	this.target = target;
	this.eventSystem = eventSystem;
	this.listenerTable = {}; // lookup by this.listenerTable[type][Boolean(capture)][index]	
}
GenericEventTarget.prototype.DESTROY = function(target) {
	this.target = null;
	this.eventSystem = null;
	this.listenerTable = null;
}
GenericEventTarget.prototype.handleEvent = function(event) {
	var capture = (event.eventPhase == Event.CAPTURING_PHASE) ? 1 : 0;
	var table = this.listenerTable[event.type];
	if (!table) return;
	var listeners = table[capture];
	for (var n=listeners.length, i=0; i<n; i++) {
		var listener = listeners[i];
		try {
			if (listener.handleEvent) return listener.handleEvent(event);
			else return listener(event);
		}
		catch (error) {
			logger.error("Error in event listener: " + error);
			return;
		}
	}
}

GenericEventTarget.prototype.addEventListener = function(type, listener, useCapture) {
	if (!this.listenerTable[type]) this.listenerTable[type] = [ [], [] ];
	var capture = (useCapture) ? 1 : 0;
	this.listenerTable[type][capture].push(listener);
}

GenericEventTarget.prototype.removeEventListener = function(type, listener, useCapture) {
	var capture = (useCapture) ? 1 : 0;
	var listeners = this.listenerTable[type][capture];
	for (var i=listeners.length-1; i>=0; i--) {
		if (listeners[i] == listener) {
			listeners.splice(i, 1);
			break;
		}
	}
}
GenericEventTarget.prototype.hasEventListener = function(type, listener, useCapture) {
	if (null == listener) {
		var tmp = this.listenerTable[type];
		if (!(tmp && (tmp[0] && tmp[0].length || tmp[1] && tmp[1].length))) return false;
	}
	var capture = (useCapture) ? 1 : 0;
	var listeners = this.listenerTable[type][capture];
	for (var i=listeners.length-1; i>=0; i--) {
		if (listeners[i] == listener) return true;
	}
	return false;
}
GenericEventTarget.prototype.dispatchEvent = function(event) {
	return this.eventSystem.dispatchEvent(this.target, event);
}

var EventTarget = function(target) {
	if (null == target) return null; // TODO throw ??
	if (this == window) return arguments.callee.getInterface(target);
	else arguments.callee.prototype.CREATE.call(this, target);
}
EventTarget.interfaceLookup = new Array(13); // NOTE potentially one for every node type + Window
EventTarget.getInterface = function(target) {
	var nodeType = (target == window) ? 0 : target.nodeType;
	var lookup = this.interfaceLookup[nodeType];
	return (lookup) ? lookup(target) : null;	
}
EventTarget.prototype.CREATE = function(target) {
	this.target = target;
	var xblPublic = ["addEventListener", "removeEventListener"];
	Meeko.stuff.domSystem.hideInterface(target, xblPublic);
	if (!target.dispatchEvent) xblPublic.push("dispatchEvent");
	Meeko.stuff.domSystem.bindInterface(target, this, xblPublic, true); // NOTE override on W3C systems
	this.baseBinding = new GenericEventTarget(target, eventSystem);
}
EventTarget.prototype.DESTROY = function(target) {
	this.target = null;
	this.baseBinding.DESTROY(target);
	// FIXME Meeko.stuff.domSystem.unbindInterface()
	target.addEventListener = null;
	target.removeEventListener = null;
	target.dispatchEvent = null;
}
EventTarget.prototype.handleEvent = function(event) {
	this.baseBinding.handleEvent(event);
}

if (window.addEventListener) {{
EventTarget.interfaceLookup[0] = Meeko.stuff.domSystem.addImplementation("Window", EventTarget);	
EventTarget.interfaceLookup[Node.DOCUMENT_NODE] = Meeko.stuff.domSystem.addImplementation("Document", EventTarget);
EventTarget.prototype.addEventListener = function(type, listener, useCapture) {
	this.baseBinding.addEventListener(type, listener, useCapture);
}
EventTarget.prototype.removeEventListener = function(type, listener, useCapture) {
	this.baseBinding.removeEventListener(type, listener, useCapture);
}
EventTarget.prototype.dispatchEvent = function(event) {
	eventSystem.dispatchEvent(this.target, event);
}
}}
else if (window.attachEvent) {{
EventTarget.interfaceLookup[0] = Meeko.stuff.domSystem.addImplementation("Window", EventTarget);
EventTarget.interfaceLookup[Node.DOCUMENT_NODE] = Meeko.stuff.domSystem.addImplementation("Document", EventTarget);
EventTarget.interfaceLookup[Node.ELEMENT_NODE] = Meeko.stuff.domSystem.addImplementation("Element", EventTarget);
EventTarget.prototype.addEventListener = function(type, listener, useCapture) {
	this.baseBinding.addEventListener(type, listener, useCapture);
	eventSystem.registerEvent(type);	
}
EventTarget.prototype.removeEventListener = function(type, listener, useCapture) {
	this.baseBinding.removeEventListener(type, listener, useCapture);
}
EventTarget.prototype.dispatchEvent = function(event) {
	eventSystem.dispatchEvent(this.target, event);
}
}}
else { throw "EventTarget only implemented with addEventListener of attachEvent"; }


if (!document.addEventListener && document.attachEvent) {{ // DOMMutation is only required on IE

var DOMMutation = function(target) {
	if (null == target) return null; // TODO throw ??
	if (this == window) return arguments.callee.getInterface(target);
	else arguments.callee.prototype.CREATE.call(this, target);
}

DOMMutation.interfaceLookup = new Array(13); // NOTE potentially one for every node type + Window
DOMMutation.interfaceLookup[Node.DOCUMENT_NODE] = Meeko.stuff.domSystem.addImplementation("Document", DOMMutation);
DOMMutation.interfaceLookup[Node.ELEMENT_NODE] = Meeko.stuff.domSystem.addImplementation("Element", DOMMutation);
DOMMutation.getInterface = function(target) {
	var nodeType = (target == window) ? 0 : target.nodeType;
	var lookup = this.interfaceLookup[nodeType];
	return (lookup) ? lookup(target) : null;
	
}
DOMMutation.methods = ["insertBefore", "replaceChild", "removeChild", "appendChild", "cloneNode"];

DOMMutation.prototype.CREATE = function(element) {
	var domMutation = this;
	this.boundElement = element;
	Meeko.stuff.domSystem.hideInterface(element, DOMMutation.methods);
	Meeko.stuff.domSystem.bindInterface(element, this, DOMMutation.methods, true);
	this.domMutation_listener = function(event) { domMutation.onpropertychange(event); }
	element.attachEvent("onpropertychange", this.domMutation_listener);
}
DOMMutation.prototype.DESTROY = function() {
	var element = this.boundElement;
	element.detachEvent("onpropertychange", this.domMutation_listener);
	// FIXME Meeko.stuff.domSystem.unbindInterface(element, this, DOMMutation.methods);
	element.insertBefore = element._insertBefore;
	element._insertBefore = null;
	element.replaceChild = element._replaceChild;
	element._replaceChild = null;
	element.removeChild = element._removeChild;
	element._removeChild = null;
	element.appendChild = element._appendChild;
	element._appendChild = null;
	element.cloneNode = element._cloneNode;
	element._cloneNode = null;
}

DOMMutation.prototype.cloneNode = function(deep) {
	var element = this.boundElement;
	var lookup = {
		"thead": [ "table" ],
		"tbody": [ "table" ],
		"tfoot": [ "table" ],
		"colgroup": [ "table" ],
		"col": [ "table", "colgroup" ],
		"tr": [ "table" ],
		"td": [ "table", "tr" ],
		"option": [ "select" ],
		"li": [ "ul" ]
	}
	var tree = lookup[element.tagName.toLowerCase()];
	var frag = document.createElement("div");
	var begin = "", end = "";
	for (var n=tree.length, i=0; i<n; i++) begin += "<" + tree[i] + ">";
	for (var i=tree.length-1; i>=0; i--) end += "</" + tree[i] + ">";
	frag.innerHTML = begin + (deep ? element.outerHTML : element.cloneNode(false).outerHTML) + end;
	var clone = frag.firstChild;
	for (var i=0; i<tree.length; i++) {
		clone = clone.firstChild;
	}
	clone.parentNode.removeChild(clone);
	return clone;
}

DOMMutation.prototype.onpropertychange = function(event) {
	if (event.propertyName == "innerHTML") {
		var element = this.boundElement;
		// FIXME should have "DOMNodeRemoved" events too
		for (var node=element.firstChild; node; node=node.nextSibling) {
			if (Node.ELEMENT_NODE != node.nodeType) continue;
			if (node["_Element"]) continue; // FIXME orthogonality - how to tell if node is newly inserted??
			this.notify("DOMNodeInserted", node, element);
		}
	}
}
DOMMutation.prototype.insertBefore = function(node, ref) {
	var result = this.boundElement._insertBefore(node, ref);
	this.notify("DOMNodeInserted", node, this.boundElement); // FIXME
	return result;
}

DOMMutation.prototype.replaceChild = function(node, old) {
	this.notify("DOMNodeRemoved", old, this.boundElement); // FIXME
	var result = this.boundElement._replaceChild(node, old);
	this.notify("DOMNodeInserted", node, this.boundElement); // FIXME
	return result;
}

DOMMutation.prototype.removeChild = function(old) {
	var element = this.boundElement;
	this.notify("DOMNodeRemoved", old, this.boundElement); // FIXME
	var result = element._removeChild(old);
	return result;
}

DOMMutation.prototype.appendChild = function(node) {
	var result = this.boundElement._appendChild(node);
	this.notify("DOMNodeInserted", node, this.boundElement); // FIXME
	return result;
}

DOMMutation.prototype.notify = function(type, node) {
	if (!document.documentElement.contains(node)) return;
	var event = document.createEvent("MutationEvent");
	event.initMutationEvent(type, true, false, this.boundElement);
	eventSystem.dispatchEvent(node, event);
}


}}

Meeko.stuff.eventSystem = eventSystem; // FIXME back-door to virtually everything

return {
	Event: Event,
	CustomEvent: CustomEvent,
	UIEvent: UIEvent,
	TextEvent: TextEvent,
	KeyboardEvent: KeyboardEvent,
	MouseEvent: MouseEvent,
	MutationEvent: MutationEvent
}

})();

Meeko.XPL.Namespace.enhance(window, Meeko.DOM.Events);

]]>
</script>
</head>
</html>