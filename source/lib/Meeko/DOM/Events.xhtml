<?xml version="1.0"?>
<?xpl-require href="../Javascript-1.6/Javascript.xhtml"?>
<?xpl-require href="../dom.xhtml"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<script type="text/javascript">
<![CDATA[

// FIXME refactor - this package has its fingers in everywhere and has back-doors for everything. Seriously yukky.

if (!this.Meeko) this.Meeko = {};

Meeko.events = (function() {

function copy(dst, src, fields, over) { // TODO maybe this should be a method on Object
	function _copy(name) {
		if (over || !dst.hasOwnProperty(name)) dst[name] = src[name];
	}
	if (fields && fields.length) {
		for (var n=fields.length, i=0; i<n; i++) {
			var name = fields[i];
			_copy(name);
		}
	}
	else {
		for (var name in src) _copy(name);
	}
	return dst;
}

function addBinding(target, bindingSpec) {
	var binding = new bindingSpec;
	binding.boundElement = target;
	for (var key in bindingSpec.prototype) {
		if (/^xbl/.test(key)) continue; // filter out xbl* methods
		(function(method) {
			target[method] = function() { return bindingSpec.prototype[method].apply(binding, arguments); }
		})(key);
	}
	if (binding.xblBindingAttached) binding.xblBindingAttached();
	return binding;
}

var w3cEventsTable = [
	{ type: "DOMActivate", bubbles: true, cancelable: true, module: "UIEvent" },
	{ type: "DOMFocusIn", bubbles: true, cancelable: false, module: "UIEvent" },
	{ type: "DOMFocusOut", bubbles: true, cancelable: false, module: "UIEvent" },
	{ type: "focus", bubbles: false, cancelable: false, module: "UIEvent" },
	{ type: "blur", bubbles: false, cancelable: false, module: "UIEvent" },
	{ type: "textInput", bubbles: true, cancelable: true, module: "TextEvent" },
	{ type: "click", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "dblclick", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "mousedown", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "mouseup", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "mouseover", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "mousemove", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "mouseout", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "keydown", bubbles: true, cancelable: true, module: "KeyboardEvent" },
	{ type: "keyup", bubbles: true, cancelable: true, module: "KeyboardEvent" },
	{ type: "mousemultiwheel", bubbles: true, cancelable: true, module: "MouseMultiWheelEvent" },
	{ type: "mousewheel", bubbles: true, cancelable: true, module: "MouseWheelEvent" },
	{ type: "DOMSubtreeModified", bubbles: true, cancelable: false, module: "MutationEvent" },
	{ type: "DOMNodeInserted", bubbles: true, cancelable: false, module: "MutationEvent" },
	{ type: "DOMNodeRemoved", bubbles: true, cancelable: false, module: "MutationEvent" },
	{ type: "DOMNodeRemovedFromDocument", bubbles: false, cancelable: false, module: "MutationEvent" },
	{ type: "DOMNodeInsertedIntoDocument", bubbles: false, cancelable: false, module: "MutationEvent" },
	{ type: "DOMAttrModified", bubbles: true, cancelable: false, module: "MutationEvent" },
	{ type: "DOMCharacterDataModified", bubbles: true, cancelable: false, module: "MutationEvent" },
	{ type: "DOMElementNameChanged", bubbles: true, cancelable: false, module: "MutationNameEvent" },
	{ type: "DOMAttributeNameChanged", bubbles: true, cancelable: false, module: "MutationNameEvent" },
	{ type: "load", bubbles: false, cancelable: false, module: "Event" },
	{ type: "unload", bubbles: false, cancelable: false, module: "Event" },
	{ type: "abort", bubbles: true, cancelable: false, module: "Event" },
	{ type: "error", bubbles: true, cancelable: false, module: "Event" },
	{ type: "select", bubbles: true, cancelable: false, module: "Event" },
	{ type: "change", bubbles: true, cancelable: false, module: "Event" },
	{ type: "submit", bubbles: true, cancelable: true, module: "Event" },
	{ type: "reset", bubbles: true, cancelable: true, module: "Event" },
	{ type: "resize", bubbles: true, cancelable: false, module: "UIEvent" },
	{ type: "scroll", bubbles: true, cancelable: false, module: "UIEvent" },
	{ type: "keypress", bubbles: true, cancelable: true, module: "KeyboardEvent" } // non-standard
];

var eventsByType = {};
for (var i=0, n=w3cEventsTable.length; i<n; i++) {
	var row = w3cEventsTable[i];
	var type = row["type"];
	eventsByType[type] = row;
}

var w3cKeyIdentifiers = {
	"U+007F": 46, // Delete
	"U+0008": 8, // Backspace
	"U+001B": 27, // Escape
	Down: 40, End: 35, Enter: 13, Home: 36, Insert: 45,
	Left: 37, PageUp: 33, PageDown: 34, Right: 39, Up: 38,
	F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123
}

var keyIdentifiersByCode = {};
for (var keyId in w3cKeyIdentifiers) {
	var code = w3cKeyIdentifiers[keyId];
	keyIdentifiersByCode[code] = keyId;
}

var toHexDigit = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F" ];
for (var i=0; i<=15; i++) {
	for (var j=0; j<=15; j++) {
		var hex = "" + toHexDigit[i] + toHexDigit[j];
		var code = Number("0x"+hex);
		var keyId = "U+00" + hex;
		if (!keyIdentifiersByCode[code]) keyIdentifiersByCode[code] = keyId;		
	}
}

var safari2bouncyKeys;
if (/AppleWebKit/.test(navigator.userAgent) && Number(navigator.userAgent.match(/[0-9]+\.[0-9]+$/)) < 500) {
	safari2bouncyKeys = copy({}, w3cKeyIdentifiers);
	delete safari2bouncyKeys["U+0008"];	
}

var WindowEventTarget = function() {};

WindowEventTarget.prototype.xblBindingAttached = function() {
	this.listenerTable = {}; // lookup by this.listenerTable[type][Boolean(capture)][index]
	this.handleEvent = function(event) {
		var capture = (event.eventPhase == Event.CAPTURING_PHASE) ? 1 : 0;
		var table = this.listenerTable[event.type];
		if (!table) return;
		var listeners = table[capture];
		for (var n=listeners.length, i=0; i<n; i++) {
			var listener = listeners[i];
			if (listener.handleEvent) listener.handleEvent(event);
			else listener(event);
		}
	}
}

WindowEventTarget.prototype.addEventListener = function(type, listener, useCapture) {
	if (!this.listenerTable[type]) this.listenerTable[type] = [ [], [] ];
	var capture = (useCapture) ? 1 : 0;
	this.listenerTable[type][capture].push(listener);
}

WindowEventTarget.prototype.removeEventListener = function(type, listener, useCapture) {
	var capture = (useCapture) ? 1 : 0;
	var listeners = this.listenerTable[type][capture];
	for (var i=listeners.length-1; i>=0; i--) {
		if (listeners[i] == listener) {
			listeners.splice(i, 1);
			break;
		}
	}
	// TODO warn on not found??
}

WindowEventTarget.prototype.dispatchEvent = function(event) {
	throw "dispatchEvent method not available on Window objects";
}

var EventSystem = function() {
	var eventSystem = this;
	this.registeredEvents = {};
	this.keyEventHistory = [];
	this.eventListener = function(event) {
		eventSystem.handleEvent(event);
	}

	this.handleEvent = function(event) { // TODO refactor
		var keyEventFields = [ "type", "keyCode", "charCode", "keyIdentifier" ];
		if ("keydown" == event.type) {
			var keyId;
			if (event.keyIdentifier) keyId = event.keyIdentifier;
			else {
				keyId = keyIdentifiersByCode[event.keyCode];
				event.keyIdentifier = keyId;
			}
			var hist = this.keyEventHistory;
			var n = hist.length;
			var prev = (n) ? hist[n-1] : null;
			var repeat = 0;
			var delta = 1;
			if (safari2bouncyKeys && keyId in safari2bouncyKeys) delta = 0.5;
			if (prev && prev.type == "keydown") repeat = prev.repeat + delta;
			else if (prev && prev.type == "keypress") repeat = prev.repeat + delta;
			hist.push(copy({ type: "keydown", repeat: repeat }, event, keyEventFields));
			if (event.defaultPrevented) event.preventDefault(); // signal from keypress
			if (repeat % 1) { // ignore bouncy key registrations
				event.stopPropagation();
			}
			else {
				this.windowEventTarget.handleEvent(event);
			}
		}
		else if ("keypress" == event.type) {
			var keyId;
			if (event.keyIdentifier) keyId = event.keyIdentifier;
			else {
				keyId = keyIdentifiersByCode[event.keyCode];
				event.keyIdentifier = keyId;
			}
			var hist = this.keyEventHistory;
			var n = hist.length;
			var prev = (n) ? hist[n-1] : null;
			var repeat = 0;
			var delta = 1;
			if (safari2bouncyKeys && keyId in safari2bouncyKeys) delta = 0.5;
			if (prev && prev.type == "keydown") repeat = prev.repeat;
			else if (prev && prev.type == "keypress") repeat = prev.repeat + delta;
			
			if (!(prev && prev.type == "keydown")) {
				event.stopPropagation();
				var newEvent;
				try {
					newEvent = document.createEvent("KeyboardEvent");
					newEvent.initKeyboardEvent("keydown", true, true, window, keyId, 0, "");
				}
				catch (error) {
					newEvent = document.createEvent("UIEvents");
					newEvent.initEvent("keydown", true, true);
					newEvent.keyIdentifier = keyId;
					newEvent.keyCode = event.keyCode;
				}
				newEvent.defaultPrevented = true; // signal to handler to prevent default
				event.target.dispatchEvent(newEvent);
			}
			if (keyId in w3cKeyIdentifiers) {
				event.stopPropagation();
			}
			else {
				event.stopPropagation();
				var newEvent = document.createEvent("TextEvent");
				newEvent.initTextEvent("textInput", true, true, window, String.fromCharCode(event.keyCode));
				event.target.dispatchEvent(newEvent);
			}
			hist.push(copy({ type: "keypress", repeat: repeat }, event, keyEventFields));
		}
		else if ("textInput" == event.type) {
			var hist = this.keyEventHistory;
			var n = hist.length;
			var prev = (n) ? hist[n-1] : null;
			if (prev.type == "keydown") {
				this.windowEventTarget.handleEvent(event);
				hist.push(copy({ type: "textInput" }, event, keyEventFields));
			}
		}
		else if ("keyup" == event.type) {
			var keyId;
			if (event.keyIdentifier) keyId = event.keyIdentifier;
			else {
				keyId = keyIdentifiersByCode[event.keyCode];
				event.keyIdentifier = keyId;
			}
			var hist = this.keyEventHistory;
			var n = hist.length;
			var prev = hist[n-1];
			if (prev.type != "keyup" || prev.keyIdentifier != keyId) {
				hist.push(copy({ type: "keyup" }, event, keyEventFields));
				this.windowEventTarget.handleEvent(event);
			}
		}
		else { // FIXME
		}
		
	}

	if (window.addEventListener) {
		for (var type in eventsByType) {
			window.addEventListener(type, this.eventListener, true);
		}
	}

	this.windowEventTarget = addBinding(window, WindowEventTarget);
}

EventSystem.prototype.registerEvent = function(type) {
	if (this.registeredEvents[type]) return;
	var system = this;
	var systemListener = function(srcEvent) {
		system.dispatchEvent(srcEvent.srcElement, srcEvent);
	}

	var ieLookup = { // FIXME ensure all standard event properties are copied / created
		"DOMAttrModified": { type: "propertychange", bubbles: false, cancelable: false },
		"DOMActivate": { type: "activate", bubbles: true, cancelable: true },
		"DOMFocusIn": { type: "focusin", bubbles: true, cancelable: false },
		"DOMFocusOut": { type: "focusout", bubbles: true, cancelable: false },
		"textInput": function() {
			window.attachEvent("onkeypress", function(srcEvent) {
				var event = document.createEvent("UIEvents");
				event.initEvent("textInput", true, true);
				event.data = String.fromCharCode(srcEvent.keyCode);
				srcEvent.returnValue = system.dispatchEvent(srcEvent.srcElement, event);
			});
		},
		"focus": function() {
			window.attachEvent("onfocusin", function(srcEvent) {
				var event = document.createEvent("UIEvents");
				event.initEvent("focus", false, false);
				srcEvent.returnValue = system.dispatchEvent(srcEvent.srcElement, event);
			});
		},
		"blur": function() {
			window.attachEvent("onfocusout", function(srcEvent) {
				var event = document.createEvent("UIEvents");
				event.initEvent("blur", false, false);
				srcEvent.returnValue = system.dispatchEvent(srcEvent.srcElement, event);
			});
		},
		"click": function() {
			document.attachEvent("onclick", function(srcEvent) {
				var event = document.createEvent("UIEvents");
				event.initEvent("click", true, true);
				event.button = ([ null, 0, 2, null, 1 ])[srcEvent.button];
				event.detail = 1;
				srcEvent.returnValue = system.dispatchEvent(srcEvent.srcElement, event);
			});
		},
		"dblclick": function() {
			document.attachEvent("ondblclick", function(srcEvent) {
				var event = document.createEvent("UIEvents");
				event.initEvent("dblclick", true, true);
				event.button = ([ null, 0, 2, null, 1 ])[srcEvent.button];
				event.detail = 2;
				srcEvent.returnValue = system.dispatchEvent(srcEvent.srcElement, event);
			});
		}
	}

	var rego = ieLookup[type] || { type: type, bubbles: true, cancelable: true};

	if (typeof rego == "function") rego();
	else document.attachEvent("on"+rego.type, systemListener);
	this.registeredEvents[type] = true;
}

EventSystem.prototype.dispatchEvent = function(target, event) {
	event.target = target;
	var path = [];
	var current = target;
	if (target != window) {
		for (current=target; current!=document; current=current.parentNode) { // FIXME will fail for document fragments, etc
			path.push(current);
		}
		path.push(document);
	}
	path.push(window);

	event.eventPhase = Event.CAPTURING_PHASE;
	for (var n=path.length, i=n-1; i>0; i--) {
		current = path[i];
		event.currentTarget = current;
		if (current._eventTarget) current._eventTarget.handleEvent(event);
		if (event.cancelBubble) return event.returnValue; 
	}

	current = path[0];
	event.eventPhase = Event.AT_TARGET;
	event.currentTarget = current;
	if (current._eventTarget) current._eventTarget.handleEvent(event);

	if (!event.bubbles) return event.returnValue;
	if (event.cancelBubble) return event.returnValue;

	event.eventPhase = Event.BUBBLING_PHASE;
	for (var n=path.length, i=1; i<n; i++) {
		current = path[i];
		event.currentTarget = current;
		if (current._eventTarget) current._eventTarget.handleEvent(event);
		if (event.cancelBubble) return event.returnValue; 
	}
	
	return event.returnValue;	
}

var eventSystem = addBinding(window, EventSystem);

var Event = function() {};
Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;

var KeyboardEvent = function() {};
KeyboardEvent.DOM_KEY_LOCATION_STANDARD = 0x00;
KeyboardEvent.DOM_KEY_LOCATION_LEFT = 0x01;
KeyboardEvent.DOM_KEY_LOCATION_RIGHT = 0x02;
KeyboardEvent.DOM_KEY_LOCATION_NUMPAD = 0x03;
	
var MutationEvent = function() {};
MutationEvent.MODIFICATION = 1;
MutationEvent.ADDITION = 2;
MutationEvent.REMOVAL = 3;

var DocumentEvent = function() {}
if (document.createEventObject) {
	
DocumentEvent.prototype.createEvent = function(module) {
	var event = document.createEventObject();
	event.initEvent = function(type, bubbles, cancelable) {
		this.type = type;
		this.bubbles = bubbles;
		this.cancelable = cancelable;
	};
	event.preventDefault = function() { this.returnValue = false; }
	event.stopPropagation = function() { this.cancelBubble = true; }
	return event;
}

var documentEvent = addBinding(document, DocumentEvent);

}

var EventTarget = function(element) { // FIXME interface removal on window.onunload
	// TODO Meeko.Namespace.enhance(_eventTarget, element);
	element._eventTarget = this;
	for (var slot in this) {
		if ("function" == typeof this[slot]) (function(iface, method) {
			element[method] = function() { iface[method].apply(iface, arguments); };
		})(this, slot);
	}
	this.boundElement = element;
	this.listenerTable = {}; // lookup by this.listenerTable[type][Boolean(capture)][index]
	this.handleEvent = function(event) {
		var capture = (event.eventPhase == Event.CAPTURING_PHASE) ? 1 : 0;
		var table = this.listenerTable[event.type];
		if (!table) return;
		var listeners = table[capture];
		for (var n=listeners.length, i=0; i<n; i++) {
			var listener = listeners[i];
			if (listener.handleEvent) listener.handleEvent(event);
			else listener(event);
		}
	}
}

EventTarget.prototype.addEventListener = function(type, listener, useCapture) {
	if (!this.listenerTable[type]) this.listenerTable[type] = [ [], [] ];
	var capture = (useCapture) ? 1 : 0;
	this.listenerTable[type][capture].push(listener);
	eventSystem.registerEvent(type);
}

EventTarget.prototype.removeEventListener = function(type, listener, useCapture) {
	var capture = (useCapture) ? 1 : 0;
	var listeners = this.listenerTable[type][capture];
	for (var i=listeners.length-1; i>=0; i--) {
		if (listeners[i] == listener) {
			listeners.splice(i, 1);
			break;
		}
	}
	// TODO warn on not found??
}

EventTarget.prototype.dispatchEvent = function(event) {
	var element = this.boundElement;
	try { return element.fireEvent("on" + event.type, event); }
	catch (error) { return eventSystem.dispatchEvent(element, event); }
}		

if (!document.addEventListener && document.attachEvent) {

var documentEventTarget = new EventTarget(document);

}

Meeko.stuff.eventSystem = eventSystem; // FIXME back-door to virtually everything

return {
	Event: Event,
	EventTarget: EventTarget,
	DocumentEvent: DocumentEvent
}

})();
]]>
</script>
</head>
</html>