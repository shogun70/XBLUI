<?xml version="1.0"?>
<?xpl-require href="../XPL/Namespace.xhtml"?>
<?xpl-require href="../Javascript-1.6/Javascript.xhtml"?>
<?xpl-require href="../DOM/DOM.xhtml"?>
<?xpl-require href="../DOM/URI.xhtml"?>
<?xpl-require href="../DOM/CSS.xhtml"?>
<?xpl-require href="../DOM/XML.xhtml"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<script type="text/javascript">
<![CDATA[

// TODO arguable everything in this first <script /> should be in it's own package
XBL_SCRIPT_URL = (function() {
	/*
	 NOTE this grabs the uri of the script by assuming that
	 the script is the last element in the tree when the script is run
	*/
	var node = document;
	var next = node.lastChild;
	while (next && next.nodeType == 1 /* Node.ELEMENT_NODE */) {
		node = next;
		next = node.lastChild;
	}
	if (node.tagName.toLowerCase() != "script") {
		logger.warn("Last element in document isn't a script");
		return null;
	}
	return node.src;
})();


Meeko.Namespace.enhance(Meeko['Javascript 1.6'], window);
Meeko.Namespace.enhance(Meeko.DOM, window);

Meeko.stuff.createGlobal("XMLHttpRequest");
XMLHttpRequest = Meeko.XML.XMLHttpRequest;
Meeko.Namespace.enhance(Meeko.XML, window);

if (!window.document.parentWindow) window.document.parentWindow = window;

if (!window.document.importNode) window.document.importNode = Document.prototype.importNode;

/*
	document.documentURI for a range of browsers
*/
var _documentURI = document.documentURI || document.baseURI || document.URL || document.url || document.location;
if (!document.documentURI) document.documentURI = _documentURI;

/*
	document.readyState for Mozilla
*/
if (!document.readyState) {
	document.readyState = "loading";
	var loadListener = function(event) {
		document.removeEventListener("DOMContentLoaded", loadListener, false);
		window.removeEventListener("load", loadListener, false);
		document.readyState = "complete";
	}
	document.addEventListener("DOMContentLoaded", loadListener, false);
	window.addEventListener("load", loadListener, false);
}

var XBLException = function(code, message) {
	if (!code) code = DOMException.NOT_SUPPORTED_ERR;
	if (!message) arguments.callee.getMessage(code);
	var instance = Error(message);
	instance.name = "DOMException";
	instance.code = code;
	return instance;
}

XBLException.getMessage = function(code) {
	if (!this.messageTable) {
		this.messageTable = [];
		for (var key in DOMException) {
			var val = DOMException[key];
			if (key.match(/_ERR$/)) this.messageTable[val] = key;
		}
	}
	return this.messageTable[code];
}



/*
	DomWalker supports the forEach method which walks the DOM (depth first)
	starting at the given element and calling the given function for every element.
*/
DomWalker = function(element) {
	this.root = element || document.documentElement;
	this.current = null;
	this.index = 0;
}

DomWalker.forEach = function(element, fn, context) { // TODO redo as per DomWalker.prototype.forEach
	var node = element;
	var next = element;
	var index = 0; // or should this be an xpath like expression?
	do {
		index++;
		if (Node.ELEMENT_NODE == node.nodeType) fn.call(context, node, index, element);
		next = node.firstChild || node.nextSibling;
		while (!next) {
			node = node.parentNode;
			if (element == node) break;
			next = node.nextSibling;
		}
		if (next) node = next;
	} while (node != element);
}


DomWalker.prototype.forEach = function(fn, context) {
	if (!this.current) {
		this.current = this.root;
		this.index++;
		fn.call(context, this.current, this.index, this.root); // assumes root is an element
	}

	OUTER: for (;;) {
		var next = this.current.firstChild;
		while (next && (Node.ELEMENT_NODE != next.nodeType || "xml" == next.tagName.toLowerCase())) next = next.nextSibling;
		var up = this.current;
		INNER: while (!next) {
			if (this.root == up) break OUTER;
			next = up.nextSibling;
			while (next && (Node.ELEMENT_NODE != next.nodeType || "xml" == next.tagName.toLowerCase())) next = next.nextSibling;
			up = up.parentNode;
		}
		this.current = next;
		this.index++;
		if (Node.ELEMENT_NODE == this.current.nodeType) fn.call(context, this.current, this.index, this.root);
	}
	
	return this.current;
}
]]>
</script>

<script type="text/javascript">
<![CDATA[ 
// TODO test object destruction
// TODO complete binding removal - delete object.x or object.x = null ??
// TODO complete filtering on event-handlers
// TODO proper DOM errors
// TODO document .onprogress & .onload


if (!this.Meeko) this.Meeko = {
	stuff: {}
};

Meeko.stuff.xblSystem = (function() {	

var xblSystems = {};
var bindingDocumentURIs = [];

var init;
var exit;

(function() {

var timerId;
var readyState = "uninitialized";	
init = function() {
	// Turn display OFF.  FIXME configuration option
	// document.documentElement.style.display = "none";
	
	var onprogress = function() { _init(); if ("complete" == readyState) clearInterval(timerId); }
	timerId = setInterval(onprogress, 10);
	if (document.addEventListener) document.addEventListener("DOMContentLoaded", onprogress, false);
	if (window.addEventListener) window.addEventListener("load", onprogress, false);
	if (window.attachEvent) window.attachEvent("onload", onprogress);
	
	if (window.addEventListener) window.addEventListener("unload", exit, false);
	if (window.attachEvent) window.attachEvent("onunload", exit);	
}

exit = function() {
	for (var uri in xblSystems) { 
		xblSystems[uri] = null; // FIXME signal sub-systems to exit as well
	}

	var domWalker = new DomWalker(view);
	domWalker.forEach(function(element) {
		var _elementXBL = element._elementXBL;
		if (_elementXBL) _elementXBL.DESTROY();
		// FIXME remove EventTarget interface
	});

	if (window.removeEventListener) window.removeEventListener("unload", exit, false);
	if (window.detachEvent) window.detachEvent("onunload", exit);
}

var _initializing = false;
var _init = function() {
	if (_initializing) { // NOTE re-entrancy has been observed on several browsers
//		logger.warn("Re-entrancy during XBL initialization");
		return false; 
	}
	_initializing = true;
	__init();
	_initializing = false;
}

var view;
var domWalker;
var uninitializedElements = [];
var uninitializedBindings = [];
var __init = function() {
	switch (readyState) { // NOTE all these cases fall-thru except for branches that return
	case "uninitialized":
		if (!document.body) return false;

		// TODO refactor
		var links = document.getElementsByTagName("link");
		for (var i=0,n=links.length; i<n; i++) {
			if (links[i].rel != "xblDocument") continue;
			xblInternalSystem.assign(links[i].href);
			break;
		}
		
		if (document.documentURI != bindingDocumentURIs[0]) {
			logger.info("XBL system in dedicated mode");
			readyState = "complete";
			return true;
		}
		logger.info("XBL is initializing");
		view = document.body;
		registerBoundDocument();
		registerXBLProcessingInstructions();
		registerXBLLinkElements();
		readyState = "pending";
		logger.info("XBL is waiting for binding documents to load");
	case "pending":
		for(var i=0, n=bindingDocumentURIs.length; i<n; i++) {
			var uri = bindingDocumentURIs[i];
			if (xblSystems[uri].getReadyState() != "complete") return false;
		}
		domWalker = new DomWalker(view);
		readyState = "interactive";
		logger.info("XBL is traversing the DOM for matched elements");
	case "interactive":
		domWalker.forEach(testElement);
		if ("complete" == document.readyState) readyState = "loaded";
		else return;
		logger.info("XBL is waiting for bindings to load");
	case "loaded":
		for (var uri in xblSystems) {
			if (xblSystems[uri].getReadyState() != "complete") return;
		}
		readyState = "attached";
		logger.info("XBL is initialising attached bindings");
	case "attached":
		var _elementXBL;
		while (_elementXBL = uninitializedElements.shift()) { // TODO configuration options
			_elementXBL.bindingChains.forEach(function(bindingChain, i) {
				bindingChain.forEach(function(binding, j) {
					if (binding.internal.xblBindingAttached) {
						try {
							binding.internal.xblBindingAttached();
						}
						catch (err) {
							alert("xblBindingAttached "+err+":\n\t"+binding.internal.boundElement.tagName.toLowerCase()+"#"+binding.internal.boundElement.id);
						}
					}
					if (binding.internal.xblEnteredDocument) uninitializedBindings.push(binding);
				});
			});
		}
		var binding;
		while (binding = uninitializedBindings.shift()) {
			try {
				binding.internal.xblEnteredDocument();
			}
			catch (err) {
				alert("xblEnteredDocument "+err+":\n\t"+binding.internal.boundElement.tagName.toLowerCase()+"#"+binding.internal.boundElement.id);
			}
		}
		// Turn display ON.  FIXME configuration option
		// this.boundDocument.documentElement.style.display = "";
		readyState = "complete";
		logger.info("XBL is complete");
	}
}

// TODO refactor this EventTarget for IE stuff
if (!document.createEvent && document.createEventObject) document.createEvent = function(eventType) {
	var event = document.createEventObject();
	event.initEvent = function(type, bubbles, cancelable) {
		this.type = type;
		this.bubbles = bubbles;
		this.cancelable = cancelable;
	}
	return event;
}

var EventTarget = function(element) {
	this.boundElement = element;
}

EventTarget.prototype.dispatchEvent = function(event) {
	var element = this.boundElement;
	var returnValue;
	try { returnValue = element.fireEvent("on" + event.type, event); }
	catch (error) {
		logger.warn("fireEvent failed: " + event.type);
		returnValue = element._elementXBL.handleEvent(event);
	}
	return returnValue;	
}

var testElement = function(element) {
	// TODO refactor
	if (!(element._eventTarget || element.dispatchEvent)) {
		var _eventTarget = new EventTarget(element);
		element._eventTarget = _eventTarget;
		// Meeko.Namespace.enhance(_eventTarget, element);
		for (var slot in _eventTarget) {
			if ("function" == typeof _eventTarget[slot]) (function(name) {
				element[name] = function() { _eventTarget[name].apply(_eventTarget, arguments); };
			})(slot);
		}
	}
	
	var _elementXBL = element._elementXBL;
	if (!_elementXBL) _elementXBL = new _ElementXBL(element, this);
	var hasBindings = false;
	forEach (bindingDocumentURIs, function(uri, docIndex) {
		var sys = xblSystems[uri];
		forEach (sys.getBindings(), function(bindingSpec, bindingIndex) {
			var selectorText = bindingSpec.element;
			var selectors = bindingSpec.elementSelectorList;
			if (!selectors) return;
			var n = selectors.length;
			var rc = false;
			for (var i=0; i<n; i++) {
				var rc = selectors[i].test(element);
				if (rc) break;
			}
			if (rc) {
				_elementXBL.configurationAddBinding(bindingSpec, new Meeko.CSS.Specificity(docIndex, bindingIndex, 0) ); // TODO abstract the precedence test
				hasBindings = true;
			}
		});
	});
	uninitializedElements.push(_elementXBL);
}


})();


var registerBoundDocument = function() {
	xblInternalSystem.init();
}

var registerXBLProcessingInstructions = function() {
	var pi = document.firstChild;
	do {
		if (document.documentElement == pi) break;
		
		if (Node.PROCESSING_INSTRUCTION_NODE != pi.nodeType) continue;
		if ("xbl" != pi.target) continue;
		var data = pi.data;
		RegExp.lastIndex = 0;
		var r = /(\w+)="([^"]*)"/g;
		var att;
		while (att = r.exec(data)) {
			var name = att[1]; var value = att[2];
			if ("href" == name) {
				registerBindingDocument(value);
			}
		}		 
	} while (pi = pi.nextSibling);
}

var registerXBLLinkElements = function() {
	var directives = document.getElementsByTagName("link");
	forEach (directives, function(link) {
//		if (link.rel == "bindings" && link.type == "text/xml") {
		if (link.rel == "bindings") {
			registerBindingDocument(link.getAttribute("href")); // NOTE use unnormalized href attribute
//			registerBindingDocument(link.href);
		}
	});
}


var registerBindingDocument = function(uri) {
	var absoluteURI = parseUri(uri, document.documentURI).toString(); // FIXME registerBindingDocument should receive absoluteURI
	bindingDocumentURIs.push(absoluteURI);
	requestXBLSystem(absoluteURI);
}

var xblSystemCallbacks = {};
var dispatchCallbacks = function(uri) {
	var callback, list = xblSystemCallbacks[uri];
	while (callback = list.shift()) {
		if ("function" == typeof callback) callback();
	}
	delete xblSystemCallbacks[uri];
}

var requestXBLSystem = function(uri, callback) {
	// FIXME the request / callback setup doesn't handle requests after the document has been received
	if (!xblSystemCallbacks[uri]) {
		xblSystemCallbacks[uri] = [];
	}

	xblSystemCallbacks[uri].push(callback);

	if (!xblSystems[uri]) {
		var xblSystem = new XBLExternalSystem();
		xblSystems[uri] = xblSystem;
		xblSystem.onreadystatechange = function() { if (xblSystem.getReadyState() != "complete") return; dispatchCallbacks(uri) };
		xblSystem.assign(uri);
	}

}


var cache = {};
var requestFile = function(uri, callback) {
	var prefetched = cache[uri];
	if (prefetched) {
		if ("function" == typeof callback) callback(prefetched);
		return prefetched;
	}
	
	var rq = new XMLHttpRequest();
	rq.open("GET", uri, true);
	rq.onreadystatechange = function() {
		if (rq.readyState != 4) return null;
		if (rq.status != 200) throw "requestFile: Error in retrieving " + uri;
		cache[uri] = rq;
		if ("function" == typeof callback) callback(rq);
	}
	rq.send("");
	return rq;
}


var parseUri = function(uri, baseURI) { // TODO XBLLocation interface
	var location = Meeko.DOM.URIParser.parseUri(uri, baseURI);
	return location;
}


var xblInternalSystem = (function() {

var sys = new function() {
	this.xblDocument = null;
	this.readyState = "uninitialized";
}

var uri = document.documentURI;
xblSystems[uri] = sys;
bindingDocumentURIs[0] = uri;

return sys;

})();

xblInternalSystem.init = function() {
	if (!document.body) throw "Cannot init xblSystem until document.body is loading";
	this._init(document);
}

xblInternalSystem.assign = function(uri) {
	var xblSystem = this;
	// FIXME
	// if (document.body) throw "Cannot assign xblDocument once document.body is loading";
	Meeko.stuff.xplSystem.documentURI = uri; // FIXME orthogonality
	this._setReadyState("loading");
	xblSystems[uri] = this;
	var oldUri = bindingDocumentURIs[0];
	bindingDocumentURIs[0] = uri;
	delete xblSystems[oldUri];
	requestFile(uri, function(rq) {
		xblSystem._init(rq.responseXML, uri);
	})
}

xblInternalSystem._init = function(doc, uri) {
	var xblSystem = this;
	if (!uri) uri = doc.documentURI;
	this.xblDocument = XBLDocument(doc, uri);
	this._setReadyState("loaded");
	this.xblDocument.init(function() {
		xblSystem._setReadyState("complete");
	});
}

xblInternalSystem._setReadyState = function(state) {
	this.readyState = state;
	if (this.onreadystatechange) this.onreadystatechange();
}

xblInternalSystem.getReadyState = function() {
	return this.readyState;
}

xblInternalSystem.getBindings = function() {
	return this.xblDocument.bindings;
}

xblInternalSystem.getBindingById = function(id) {
	return this.xblDocument.namedBindings[id];
}

var XBLExternalSystem = function() {
	this.readyState = "uninitialized";
	this._connected = false;
	this.iframe = document.createElement("iframe");
	this.iframe.style.height = "0";
	this.iframe.style.width = "0";
	this.iframe.style.position = "absolute";
	this.iframe.style.top = "0";
	this.iframe.style.left = "-10px";
	this.iframe.style.borderWidth = "0px";
	document.body.insertBefore(this.iframe, document.body.firstChild);
}

XBLExternalSystem.prototype.assign = function(href) {
	this.readyState = "loading";
	this.documentURI = href;
	var iframe = this.iframe;
	var win = iframe.contentWindow;
	var doc = win.document;
	var xblSystem = this;
	iframe.onload = function() {
		xblSystem._connect();
	}

	var htmlText = "";
	htmlText += "<html><head>";
	htmlText += "<link rel='xblDocument' type='application/xml' href='" + href + "' />";
	htmlText += "<script src='"+ XBL_SCRIPT_URL +"'><\/script>";
	htmlText += "<\/head><body><\/body><\/html>";
	doc.open();
	doc.write(htmlText);
	doc.close();
}

XBLExternalSystem.prototype._connect = function() {
	var xblSystem = this;
	if (this._connected) return;
	var iframe = this.iframe;
	var win = iframe.contentWindow;
	if (win.Meeko) {
		var remoteSystem = win.Meeko.stuff.xblSystem;
		remoteSystem.onreadystatechange = function() { xblSystem._setReadyState(remoteSystem.getReadyState()) };
		this._connected = true;
		xblSystem._setReadyState(remoteSystem.getReadyState());
	}
}

XBLExternalSystem.prototype._setReadyState = function(state) { // FIXME
	var lookup = {	
		"uninitialized": 0,
		"loading": 1,
		"loaded": 2,
		"complete": 3
	}
	
	if (lookup[state] > lookup[this.readyState]) {
		this.readyState = state;
		if (this.onreadystatechange) this.onreadystatechange();
	}
}

XBLExternalSystem.prototype.getReadyState = function() {
	if (!this._connected) this._connect();
	return this.readyState;
}

XBLExternalSystem.prototype.getBindings = function() {
	if (!this._connected) this._connect();
	if (this.readyState != "complete") throw "Bindings not ready";
	var win = this.iframe.contentWindow;
	var xblSystem = win.Meeko.stuff.xblSystem;
	return xblSystem.getBindings();
}

XBLExternalSystem.prototype.getBindingById = function(id) {
	if (!this._connected) this._connect();
	if (this.readyState != "complete") throw "Bindings not ready";
	var win = this.iframe.contentWindow;
	var xblSystem = win.Meeko.stuff.xblSystem;
	return xblSystem.getBindingById(id);
}

/*
	interface ElementXBL {
		readonly attribute XBLImplementationList xblImplementations;
		void addBinding(in DOMString bindingURI);
		void removeBinding(in DOMString bindingURI);
		boolean hasBinding(in DOMString bindingURI);
	}
*/

var _ElementXBL = function(element) {
	element._elementXBL = this;
	this.boundElement = element;
	this.bindingChains = [];

	var _elementXBL = this;
	this.methods = {};

	this.eventListener = function(event) { _elementXBL.handleEvent(event); }
	this.events = {};
}

_ElementXBL.prototype.DESTROY = function() {
	var element = this.boundElement;
	var bindingChains = this.bindingChains;
	var chain;
	while (chain = bindingChains.pop()) {
		this.deleteBindingChain(chain);		
	}

	for (var methodName in this.methods) {
		// delete element[methodName];
		element[methodName] = null;
	}
	for (var evType in this.events) {
		if (element.removeEventListener) element.removeEventListener(evType, this.eventListener, false); // W3C
		if (element.detachEvent) element.detachEvent(evType, this.eventListener); // IE
	}
	
	// delete element._elementXBL;
	element._elementXBL = null;
	this.boundElement = null;
}


_ElementXBL.prototype.configurationAddBinding = function(bindingSpec, specificity) {
	// NOTE in case a required XBLDocument is not loaded, this function requests the document
	// and adds a callback which just starts the function from scratch
	var _elementXBL = this;
	var callback = function() { _elementXBL.configurationAddBinding(bindingSpec, specificity); }
	var specList = [];
	var spec = bindingSpec;
	
	while (spec) {
		specList.unshift(spec);
		if (!spec.baseBindingURI) break;
		var bindingURI = parseUri(spec.baseBindingURI, spec.xblDocument.documentURI);
		var xblSystem = xblSystems[bindingURI.href];
		if (xblSystem && xblSystem.getReadyState() == "complete") {
			spec = xblSystem.getBindingById(bindingURI.anchor);
		}
		else {
			requestXBLSystem(bindingURI.href, callback);
			return;
		}
	}
	
	var chain = [];
	var baseBinding;
	var binding;
	while (spec = specList.shift()) {
		baseBinding = binding;
		binding = new XBLBinding(spec);
		if (baseBinding) binding.setBaseBinding(baseBinding);
		chain.push(binding);
	}
	
	var element = this.boundElement;
	
	chain.context = XBLBinding.CONFIGURATION_CONTEXT;
	chain.specificity = specificity;

	var bindingChains = _elementXBL.bindingChains;
	var superChain;
	for (var i=0; superChain=bindingChains[i]; i++) {
		if (XBLBinding.CONFIGURATION_CONTEXT != superChain.context) break;
		if (Meeko.CSS.Specificity.cmp(specificity, superChain.specificity) < 0) break;
	}

	if (i > 0) {	
		var baseChain = bindingChains[i-1];
		var baseBinding = baseChain[baseChain.length-1];
		chain[0].setBaseBinding(baseBinding);
	}
	if (superChain) superChain[0].setBaseBinding(chain[chain.length-1]);
	this.insertBindingChain(chain, i);
}

_ElementXBL.prototype.deleteBindingChain = function(chain) {
	var binding = null;
	while (binding = chain.shift()) { // FIXME
		binding.setBaseBinding(null);
		this.detachBinding(binding);
		binding.DESTROY();
	}
}

_ElementXBL.prototype.insertBindingChain = function(chain, index) {
	var _elementXBL = this;
	var element = this.boundElement;
	this.bindingChains.splice(index, 0, chain);
	
	forEach (chain, function(binding, chainIndex) {
		binding.attach(element);
		for (var key in binding.external) { // FIXME filter out base-prototype methods, e.g. prototype[key] == Object.prototype[key];
			if (/^xbl/.test(key)) continue; // filter out xbl* methods
			var bCopy = false;
			if (!(key in element)) bCopy = true;
			else { // can over-ride lower order bindings, but not inbuilt or higher order
				var baseBinding = binding;
				while (baseBinding = baseBinding.baseBinding) {
					var external = baseBinding.external;
					if (external.__defineGetter__) { // TODO better getter setter tester
						var getter = baseBinding.external.__lookupGetter__(key);
						var setter = baseBinding.external.__lookupSetter__(key);
						if ((getter || setter) && element.__lookupGetter__(key) == getter && element.__lookupSetter__(key) == setter) {
							bCopy = true;
							break;
						}
					}
					if (!(getter || setter) && element[key] == baseBinding.external[key]) {
						bCopy = true;
						break;
					}
				}
			}
			if (bCopy) {
				var external = binding.external;
				if (external.__defineGetter__) { // TODO better getter setter tester
					var getter = external.__lookupGetter__(key);
					if (getter) element.__defineGetter__(key, getter);
					var setter = external.__lookupSetter__(key);
					if (setter) element.__defineSetter__(key, setter);
				}
				if (getter || setter) continue;
				element[key] = external[key];
			}
		}
		
		forEach (binding.handlers, function(handler) {
			// FIXME hack for textInput -> keypress
			var eventType = handler.event;
			if ("textInput" == eventType) eventType = "keypress";
			if (!this.events[eventType]) { // TODO what to do about handler.phase??
				if (element.addEventListener) element.addEventListener(eventType, this.eventListener, false); // W3C
				else element.attachEvent("on"+eventType, this.eventListener); // IE
				this.events[eventType] = true;
			}
		}, _elementXBL);
	
	}, this);

	return chain;
}

_ElementXBL.prototype.attachBinding = function(binding) {
	var _elementXBL = this;
	var element = this.boundElement;
	binding.attach(element);
	
	for (var key in binding.implementation.prototype) {
		if (binding.implementation.prototype[key] instanceof Function) (function(methodName) {
			if (/^_/.test(methodName)) return; // functions starting with underscore (_) are private
			if (element[methodName]) return; // don't over-ride existing properties or methods. TODO configuration option
			element[methodName] = function() { return _elementXBL.doMethod(methodName, arguments); };
			_elementXBL.methods[methodName] = true;
		})(key);
	}
	
	forEach (binding.handlers, function(handler) {
		// FIXME hack for textInput -> keypress
		var eventType = handler.event;
		if ("textInput" == eventType) eventType = "keypress";
		if (!this.events[eventType]) { // TODO what to do about handler.phase??
			if (element.addEventListener) element.addEventListener(eventType, this.eventListener, false); // W3C
			else element.attachEvent("on"+eventType, this.eventListener); // IE
			this.events[eventType] = true;
		}
	}, _elementXBL);

	if (binding.internal.xblEnteredDocument || binding.internal.xblBindingAttached) // TODO this should be in a callback
		uninitialisedBindings.push(binding);
	
}

_ElementXBL.prototype.detachBinding = function(binding) {
	binding.detach();
}

_ElementXBL.prototype.doMethod = function(methodName, argList) {
	var nChains = this.bindingChains.length;
	for (var i=nChains-1; i>=0; i--) {
		var chain = this.bindingChains[i];
		var nBindings = chain.length;
		for (var j=nBindings-1; j>=0; j--) {
			var binding = chain[j];
			var object = binding.internal;
			if (object[methodName]) return object[methodName].apply(object, argList);
		}
	}
	throw methodName + " is not a function";
}

_ElementXBL.prototype.handleEvent = function(event) {
	var nChains = this.bindingChains.length;
	for (var i=nChains-1; i>=0; i--) {
		var chain = this.bindingChains[i];
		var nBindings = chain.length;
		for (var j=nBindings-1; j>=0; j--) {
			var binding = chain[j];
			binding.handleEvent(event);
		}
	}
}


var XBLBinding = function(spec) {
	var implementation = spec.implementation || Object;
	var internal = new implementation;
	var external = {};
	internal.external = external;
	var prototype = implementation.prototype;
	for (var key in prototype) {
		if (/^_/.test(key)) continue; // functions starting with underscore (_) are internal / private
		if (prototype.__defineGetter__) { // TODO better getter setter tester
			var getter = prototype.__lookupGetter__(key);
			if (getter) (function(name, method, object) {
				external.__defineGetter__(name, function() { return method.apply(object, arguments); });
			})(key, getter, internal);
			var setter = prototype.__lookupSetter__(key);
			if (setter) (function(name) {
				external.__defineSetter__(name, function() { return method.apply(object, arguments); });
			})(key, getter, internal);
		}
		if (getter || setter) continue;
		var slot = prototype[key];
		if ("function" == typeof slot) (function(name, method, object) {
			external[name] = function() { return method.apply(object, arguments); };
		})(key, slot, internal);
		else external[key] = internal[key]; // TODO what about objects, arrays, etc
	}
	this.specification = spec;
	this.implementation = spec.implementation;
	this.external = external;
	this.internal = internal;
	this.handlers = spec.handlers;
	this.baseBinding = null;
}

XBLBinding.SYSTEM_CONTEXT = 0;
XBLBinding.CONFIGURATION_CONTEXT = 1;
XBLBinding.CSS_CONTEXT = 2;
XBLBinding.IMMEDIATE_CONTEXT = 3;


XBLBinding.prototype.DESTROY = function() {}

XBLBinding.prototype.setBaseBinding = function(binding) {
	var oldBinding = this.baseBinding;
	this.baseBinding = (binding) ? binding : null;
	this.internal.baseBinding = (binding) ? binding.internal : null;
	return oldBinding;
}

XBLBinding.prototype.getBaseBinding = function() { // TODO is this necessary??
	return this.baseBinding;
}

XBLBinding.prototype.attach = function(element) {
	this.internal.boundElement = element;
}

XBLBinding.prototype.detach = function() {
	this.internal.boundElement = null;
}

XBLBinding.prototype.handleEvent = function(event) {
	var object = this.internal;
	var handlers = this.handlers;
	forEach (handlers, function(handler) { // TODO make cross-browser implementation more efficient
		// Event Filtering:

		// type
		var xblEvents = { click: true, mousedown: true, mouseup: true, mouseover: true, mouseout: true, mousemove: true,
			keydown: true, keyup: true, textInput: true, DOMAttrModified: true,
			load: true, unload: true, abort: true, error: true, select: true, change: true, submit: true, reset: true, resize: true, scroll: true };
		var xblClickEvents = { click: true };
		var xblMouseEvents = { mousedown: true, mouseup: true, mouseover: true, mouseout: true, mousemove: true };
		var xblKeyboardEvents = { keydown: true, keyup: true };
		var xblTextEvents = { textInput: true };
		var xblMutationEvents = { DOMAttrModified: true };
		var xblHTMLEvents = { load: true, unload: true, abort: true, error: true, select: true, change: true, submit: true, reset: true, resize: true, scroll: true };

		var clickEvents = { dblclick: true, click: true };
		var mouseEvents = { mousedown: true, mouseup: true, mouseover: true, mouseout: true, mousemove: true };
		var keyboardEvents = { keydown: true, keyup: true };
		var textEvents = { textInput: true, keypress: true };
		var mutationEvents = { DOMAttrModified: true, propertychange: true };
		var htmlEvents = { load: true, unload: true, abort: true, error: true, select: true, change: true, submit: true, reset: true, resize: true, scroll: true };

		// no handler.event is an error
		if (!handler.event) return;

		// phase.  In this implementation bubbling phase incorporates target phase.  TODO check with spec
		if (event.eventPhase) { // W3C
			if (event.eventPhase != handler.phase) {
				if (Event.BUBBLING_PHASE != handler.phase) return;
				if (Event.AT_TARGET != event.eventPhase) return;
			}
		}
		else { // IE
			if (Event.CAPTURING_PHASE == handler.phase) return; // capture not supported in IE
			if (Event.AT_TARGET == handler.phase && event.srcElement != object.boundElement) return;
		}

		// MouseEvents		
		if (handler.event in xblMouseEvents) { // FIXME check the filtering logic, esp handler.event == event.type
			if (event.type != handler.event) return;
			if (handler.modifiers) {
				if (!this.filterEventByModifiers(event, handler.modifiers)) return;
			}
		}
		
		// ClickEvents
		if (handler.event in xblClickEvents) {
			if (!(event.type in clickEvents)) return;
			if (handler.button && handler.button.length) { // TODO fix for Safari2
				var button = 0;
				if (event.target) button = event.button; // W3C
				else /* if (event.srcElement) */ { // IE
					button = ([ null, 0, 2, null, 1 ])[event.button];
					// TODO what do higher handler.button values represent??
				}
				if (handler.button.indexOf(button) == -1) return;
			}
			if (handler.clickCount && handler.clickCount.length) { // TODO cross-platform testing, esp dblclick
				var count = 1;
				if ("dblclick" == event.type) count = 2;
				if ("click" == event.type) count = (event.detail) ? event.detail : 1;
				if (handler.clickCount.indexOf(count) == -1) return;
			}
			
			if (handler.modifiers) {
				if (!this.filterEventByModifiers(event, handler.modifiers)) return;
			}
		}

		// KeyboardEvents
		// TODO more flexible, comprehensive key-map
		// NOTE some of these are non-standard
		var keyIdentifiers = {
			Backspace: 8, Delete: 46, Down: 40, End: 35, Enter: 13, Escape: 27, Home: 36, Insert: 45, Left: 37, PageUp: 33, PageDown: 34, Right: 39, Space: 32, Tab: 9, Up: 38,
			F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123
		}
		if (handler.event in xblKeyboardEvents) {
			if (event.type != handler.event) return;
			if (handler.key) {
				var keyId = keyIdentifiers[handler.key];
				if (event.keyCode != keyId) return;
			}

			// TODO key, key-location
			
			if (handler.modifiers || handler.key) {
				if (!this.filterEventByModifiers(event, handler.modifiers || [ "none" ])) return;
			}
		}
		
		// TextEvents
		if (handler.event in xblTextEvents) { // FIXME keypress events don't have the textInput data property
			if (!(event.type in textEvents)) return;
			if (handler.text) {
				if ("textEvent" == event.type && handler.text != event.data) return;
				if ("keypress" == event.type) {
					var charCode = event.charCode || event.keyCode;
					if (handler.text != String.fromCharCode(charCode)) return;
				}
			}
		}
		
		// MutationEvents
		if (handler.event in xblMutationEvents) { // FIXME onpropertychange for IE
			if (!(event.type in mutationEvents)) return;
			if (handler.attrName) {
				// mutation attribute name
				if (handler.attrName != event.attrName) return;
				// mutation type
				if (handler.attrChange.length > 0 && handler.attrChange.indexOf(event.attrChange) < 0) return;
				// previous value
				if (MutationEvent.MODIFICATION == event.attrChange || MutationEvent.REMOVAL == event.attrChange)
					if (null != handler.prevValue && handler.prevValue != event.prevValue) return;
				// new value
				if (MutationEvent.MODIFICATION == event.attrChange || MutationEvent.ADDITION == event.attrChange)
					if (null != handler.newValue && handler.newValue != event.newValue) return;
			}
		}
			
		// HTML events
		if (handler.event in xblHTMLEvents) {
			if (!(event.type == handler.event)) return;
		}
		
		// user-defined events.  TODO should these be optionally allowed / prevented??
		if (!(handler.event in xblEvents)) {
			if (!(event.type == handler.event)) return;
		}

		// execute handler code
		if (handler.action) try {
			handler.action.call(object, event);
		}
		catch(err) {
		}
		
		// 
		if (handler.defaultPrevented) {
			if (event.preventDefault) event.preventDefault(); // W3C
			else event.returnValue = false; // IE
		}
		if (handler.propagationStopped) {
			if (event.stopPropagation) event.stopPropagation(); // W3C
			else event.cancelBubble = true; // IE
		}
	}, this);

}

XBLBinding.prototype.filterEventByModifiers = function(event, modifiers) {
	// TODO comprehensive modifiers list
	// event.getModifierState() -> evMods
	// Need to account for any positives
	// Fields are set to -1 when accounted for
	var evMods = {
		control: event.ctrlKey,
		shift: event.shiftKey,
		alt: event.altKey,
		meta: event.metaKey
	};

	var evMods_any = event.ctrlKey || event.shiftKey || event.altKey || event.metaKey;
	var evMods_none = !evMods_any;

	var any = false;

	if (modifiers)	{
		for (var i=0, n=modifiers.length; i<n; i++) {
			var modifier = modifiers[i];
			switch (modifier.key) {
				case "none":
					if (evMods_any) return false;
					break;
	
				case "any":
					any = true;
					break;
	
				default:
					var active = evMods[modifier.key];
					switch (modifier.condition) {
						case -1:
							if (active) return false;
							break;
						case 0:
							if (active) evMods[modifier.key] = -1;
							break;
						case 1:
							if (!active) return false;
							evMods[modifier.key] = -1;
							break;
					}				
			}
		}
	}
	
	if (any) return true;
	
	// Fail if any positive modifiers not accounted for
	for (var key in evMods) {
		if (evMods[key] > 0) return false;
	}
	return true;
}

/*
	XBL document & element wrappers
	TODO: complete XBLHandlerELement
	TODO: use childNodes rather than getElementsByTagName
	TODO: namespaces
	TODO: how do we handle XBL & non-XBL documents?
	TODO: clean up the process of adding xblDocument property to XBLBindingElements
	TODO: tight binding of wrappers??
	TODO: XBLDocument.eval or some-such
*/

function getTextContent(element) {
	var text = "";
	if (null != element.textContent) text = element.textContent; // W3C
	else if (null != element.text) text = element.text; // IE
	else for (var textNode=element.firstChild; null!=textNode; textNode=textNode.nextSibling) { // Safari2
		if (Node.TEXT_NODE == textNode.nodeType || Node.CDATA_SECTION_NODE == textNode.nodeType)
			text += textNode.nodeValue;
	}
	return text;
}

function getChildByTagName(element, tagName) {
	for (var node=element.firstChild; node; node=node.nextSibling) {
		if (node.tagName == tagName) return node;
	}
	return null;
}

function getChildrenByTagName(element, tagName) {
	var children = [];
	for (var node = element.firstChild; node; node=node.nextSibling) {
		if (tagName == node.tagName) children.push(node);
	}
	return children;
}

var XBLDocument = function(_document, documentURI) { // TODO documentURI is available via _document, except in IE
	if (!(this instanceof arguments.callee)) return new arguments.callee(_document, documentURI);

	this._target = _document;
	this.defaultView = window; // FIXME _document.parentWindow, etc

//	this.documentURI = _document.documentURI || _document.baseURI || _document.URL || documentURI;
	this.documentURI = documentURI;

	this.styleSheets = [];
	this.xblElements = [];
	this.bindings = [];
	this.namedBindings = {};
	this.readyState = "uninitialized";
	
}

XBLDocument.prototype.init = function(callback) {
	this._callback = callback;
	var _document = this._target;
	this._xblTrees = [];

	var xblDoc = this;	
	if (_document == document) {
		var styleElts = _document.getElementsByTagName("style");
		forEach(styleElts, function(elt) {
			switch (elt.type) { case "application/xml": case "text/xml": break; default: return; };
			var text = elt.textContent || elt.innerHTML;
			var xml = (new DOMParser).parseFromString(text, "application/xml"); // TODO catch errors
			xblDoc.styleSheets.push(xml);
			xblDoc._xblTrees.push(xml.documentElement);
		});
	}
	else {
		forEach(_document.getElementsByTagName("xbl"), function(node) {
			xblDoc._xblTrees.push(node);
		})
	}

	this._init();
}

XBLDocument.prototype._init = function() {
	var xblDoc = this;
	var elt;
	if (elt = xblDoc._xblTrees.shift()) {
		xblDoc._addXBLTree(elt, function() { xblDoc._init(); })
		return;
	};
	this.readyState = "complete";	
	if (this._callback) this._callback(this);
}


XBLDocument.prototype._addXBLTree = function(elt, callback) {
	var xblDoc = this;
	var n = this.xblElements.length;
	if (n && this.xblElements[n-1].readyState != "complete") throw "_addXBLTree failed: previous request not completed";
	var xblElt = XBLXblElement(elt, this);
	this.xblElements.push(xblElt);
	xblElt.init(function() {
		xblDoc.bindings = xblDoc.bindings.concat(xblElt.bindings);
		forEach (xblElt.bindings, function(binding) {
			if (binding.id && !xblDoc.namedBindings[binding.id]) xblDoc.namedBindings[binding.id] = binding;
		});	
		
		if (callback) callback();
	});
}


var XBLXblElement = function(_element, _document) {
	if (!(this instanceof arguments.callee)) return new arguments.callee(_element, _document);

	this.readyState = "uninitialized";
	if ("xbl" != _element.tagName.toLowerCase()) throw 'XBLXblElement interface only valid for "xbl" elements';
	this._target = _element;
	this.xblDocument = _document;
	this.bindings = [];
	
}

XBLXblElement.prototype.init = function(callback) {
	this._callback = callback;
	this.readyState = "loading";
	this._current = this._target.firstChild;
	this._init();
}

XBLXblElement.prototype._init = function() {
	var _element = this._target;
	var _document = this.xblDocument;
	var xblElement = this;

	while (this._current) {
		var node = this._current;
		this._current = node.nextSibling;		
		if (Node.ELEMENT_NODE != node.nodeType) continue;
		if ("script" == node.tagName.toLowerCase()) {
			var src = node.getAttribute("src");
			var jsText = "";
			if (src) {
				var uri = parseUri(src, _document.documentURI);
				requestFile(uri, function(rq) { // TODO deal with failed requests
					jsText = rq.responseText;
					Meeko.stuff.execScript(jsText, function(state) {
						if (state != "complete") logger.warn("Error in script");
						xblElement._init();  // and get back in the loop;
					});
				});
				return; // leave the loop until the requestFile callback
			}
			else { // TODO refactor this duplication of execScript
				jsText = getTextContent(node);	
				Meeko.stuff.execScript(jsText, function(state) {
					if (state != "complete") logger.warn("Error in script");
					xblElement._init();
				}); // back in the loop
				return;
			}			

		}
		if ("binding" == node.tagName.toLowerCase()) {
			var binding = XBLBindingElement(node, this.xblDocument);
			this.bindings.push(binding);
			binding.init();
		}
	}

	this.readyState = "complete";
	if (this._callback) this._callback();
}

var XBLBindingElement = function(_element, _document) {
	if (!(this instanceof arguments.callee)) return new arguments.callee(_element, _document);

	if ("binding" != _element.tagName.toLowerCase()) throw 'XBLBindingElement interface only valid for "binding" elements';
	this._target = _element;
	this.xblDocument = _document;
}

XBLBindingElement.prototype.init = function() {
	var binding = this;
	var _element = this._target;
	var _document = this.xblDocument;
	this.id = _element.getAttribute("id");
	this.element = _element.getAttribute("element");
	this.elementSelectorList = (this.element) ? cssParser.parseSelectors(this.element) : null;
	this.baseBindingURI = _element.getAttribute("extends");
	
	this.implementation = function() {};
	this.handlers = [];
	this.resources = [];
	this.template = null;
	
	var XBLHandlers = function(_element) {
		for (var node=_element.firstChild; node; node=node.nextSibling) {
			if (Node.ELEMENT_NODE != node.nodeType) continue;
			var tagName = node.tagName.toLowerCase();
			switch (tagName) {
				case "handler":
					var handler = XBLHandlerElement(node, _document);
					binding.handlers.push(handler);
					handler.init();
					break;
				
				default:
					logger.warn("Ignoring " + tagName + " element: invalid child of xbl:handlers");
					break;				
			}
		}
	}

	// TODO refactor child element parsing
	var implementationElts = [];
	var handlersElts = [];
	var resourcesElts = [];
	var templateElts = [];

	for (var node=_element.firstChild; node; node=node.nextSibling) {
		if (Node.ELEMENT_NODE != node.nodeType) continue;
		var tagName = node.tagName.toLowerCase();
		switch (tagName) {
			case "implementation":
				implementationElts.push(node);
				if (implementationElts.length <= 1) {
					var jsText = getTextContent(node);
					try {
						this.implementation.prototype = Meeko.stuff.evalScript.call(window, jsText);
					}
					catch (error) {
						logger.warn("Error in xbl:implementation script"); // FIXME more specific message
					}
				}
				else {
					logger.warn("Ignoring xbl:implementation element: only first instance is valid");
				}
				break;
			
			case "template":
				implementationElts.push(node);
				if (templateElts.length <= 1) {
					logger.warn("Ignoring xbl:template element: feature not implemented");
					this.template = node;
				}
				else {
					logger.warn("Ignoring xbl:template element: only first instance is valid");
				}
				break;
			
			case "handlers":
				handlersElts.push(node);
				if (handlersElts.length <= 1) {
					XBLHandlers(node);
				}
				else {
					logger.warn("Ignoring xbl:handlers element: only first instance is valid");
				}
				break;
			
			case "resources":
				resourcesElts.push(node);
				if (resourcesElts.length <= 1) {
					logger.warn("Ignoring xbl:resources element: feature not implemented");
				}
				else {
					logger.warn("Ignoring xbl:resources element: only first instance is valid");
				}
				break;
			
			default:
				logger.warn("Ignoring " + tagName + " element: invalid child of xbl:binding");
				break;
		}
	}

	return this;
}

XBLHandlerElement = function(_element, _document) {
	if (!(this instanceof arguments.callee)) return new arguments.callee(_element, _document);

	if ("handler" != _element.tagName.toLowerCase()) throw 'XBLHandlerElement interface only valid for "handler" elements';
	this._target = _element;
	this.xblDocument = _document;
}

XBLHandlerElement.prototype.init = function() {
	var _element = this._target;
	var _document = this._document;
	this.event = _element.getAttribute("event");
	if (null == this.event) logger.warn("Invalid handler: empty event attribute");

	function lookupValue(attrName, lookup) {
		var attrValue = _element.getAttribute(attrName);
		var result;
		if (attrValue) {
			result = lookup[attrValue];
			if (null == result) logger.info("Ignoring invalid @" + attrName + ": " + attrValue);
		}
		return result;
	}

	this.phase = lookupValue("phase", {
		"capture": Event.CAPTURING_PHASE,
		"target": Event.AT_TARGET,
		"bubble": Event.BUBBLING_PHASE,
		"default-action": 2019716164
	}) || Event.BUBBLING_PHASE;

	this.defaultPrevented = lookupValue("default-action", {
		"cancel" : true,
		"perform" : false
	}) || false;

	this.propagationStopped = lookupValue("propagate", {
		"stop": true,
		"continue": false
	}) || false;
	
	function attrText_to_numArray(attr) {				
		var attrText = _element.getAttribute(attr);
		if (!attrText) return null;
		var result = [];
		var strings = attrText.split(/\s+/);
		forEach (strings, function(text) {
			var num = Number(text);
			if (NaN != num && Math.floor(num) == num) result.push(num);
		});
		return result;
	}

	// Event Filters: mouse / keyboard / text / mutation / modifiers
	
	// mouse
	this.button = attrText_to_numArray("button");
	this.clickCount = attrText_to_numArray("click-count");
	
	// keyboard
	this.key = _element.getAttribute("key");
	this.keyLocation = [];
	var keyLocationText = _element.getAttribute("key-location");
	var keyLocationStrings =  (keyLocationText) ? keyLocationText.split(/\s+/) : [];
	forEach(keyLocationStrings, function(text) {
		switch (text) {
			case "standard": this.keyLocation.push(KeyboardEvent.DOM_KEY_LOCATION_STANDARD); break;
			case "left": this.keyLocation.push(KeyboardEvent.DOM_KEY_LOCATION_LEFT); break;
			case "right": this.keyLocation.push(KeyboardEvent.DOM_KEY_LOCATION_RIGHT); break;
			case "numpad": this.keyLocation.push(KeyboardEvent.DOM_KEY_LOCATION_NUMPAD); break;
		}
	}, this);

	// text
	this.text = _element.getAttribute("text");
	
	// non-standard
	this.filter = new RegExp(_element.getAttribute("filter"), "");
	
	// mutation
	this.attrName = _element.getAttribute("attr-name");
	this.attrChange = [];
	var attrChangeText = _element.getAttribute("attr-change");
	var attrChangeStrings =  (attrChangeText) ? attrChangeText.split(/\s+/) : [];
	forEach(attrChangeStrings, function(text) {
		switch (text) {
			case "modification": this.attrChange.push(MutationEvent.MODIFICATION); break;
			case "addition": this.attrChange.push(MutationEvent.ADDITION); break;
			case "removal": this.attrChange.push(MutationEvent.REMOVAL); break;
		}
	}, this);
	this.prevValue = _element.getAttribute("prev-value");
	this.newValue = _element.getAttribute("new-value");
	
	// modifiers
	// TODO should this.modifiers be {} or []?
	if (null != _element.getAttribute("modifiers")) {
		this.modifiers = [];
		var modifiersText = _element.getAttribute("modifiers");
		var modifiersStrings = (modifiersText) ? modifiersText.split(/\s+/) : [];
		forEach (modifiersStrings, function(text) { // TODO check parser
			var m;
			m = /^([+-]?)([a-z]+)(\??)$/.exec(text);
			if (m) {
				var key = m[2];
				var condition = 1; // MUST
				if (m[3]) condition = 0; // OPTIONAL
				else if (m[1] == "+") condition = 1; // MUST
				else if (m[1] == "-") condition = -1; // MUST NOT
				this.modifiers.push({ key: key, condition: condition });
			}
		}, this);
	}
	else this.modifiers = null;

	var jsText = getTextContent(_element);
	if (jsText) {
		try {
			this.action = Function("event", jsText);
		}
		catch (error) {
			logger.warn("Parse error in handler"); // FIXME more specific message
		}
	}
	return this;
}

var cssParser = new Meeko.CSS.Parser();

init();

return xblInternalSystem;

})();

]]>
</script>
</head>
</html>