<?xml version="1.0"?>
<?xpl-require href="Javascript-1.6/Javascript.xhtml"?>
<html>
<head>
<script>
<![CDATA[

var enhance = Meeko.XPL.Namespace.enhance;
enhance(window, Meeko['Javascript 1.6']);

if (!this.Meeko) this.Meeko = {};
if (!this.Meeko.DOM) this.Meeko.DOM = {};

Meeko.DOM.Core = (function() {
	
var Node = function() {};
Node.ELEMENT_NODE = 1;
Node.ATTRIBUTE_NODE = 2;
Node.TEXT_NODE = 3;
Node.CDATA_SECTION_NODE = 4;
Node.ENTITY_REFERENCE_NODE = 5;
Node.ENTITY_NODE = 6;
Node.PROCESSING_INSTRUCTION_NODE = 7;
Node.COMMENT_NODE = 8;
Node.DOCUMENT_NODE = 9;
Node.DOCUMENT_TYPE_NODE = 10;
Node.DOCUMENT_FRAGMENT_NODE = 11;
Node.NOTATION_NODE = 12;

var Text = function() {};

var Document = function() {};

Document.prototype.importNode = function(node, bDeep) {
	var document = this;
	var tree;
	switch (node.nodeType) {
		case Node.ELEMENT_NODE:
			tree = document.createElement(node.nodeName);
			var attrs = node.attributes;
			for (var i=0; i<attrs.length; i++) {
				var attr = attrs[i];
				tree.setAttribute(attr.nodeName, attr.nodeValue);
			};
			var children = node.childNodes;
			if (bDeep) for (var i=0; i<children.length; i++) {
				var child = children[i];
				tree.appendChild(document.importNode(child, true));
			};
			break;
		case Node.CDATA_SECTION_NODE:
		case Node.TEXT_NODE:
			tree = document.createTextNode(node.nodeValue);
			break;
	}
	return tree;
}

var Element = function() {}


var DOMException = function() {};

DOMException.INDEX_SIZE_ERR = 1;
DOMException.DOMSTRING_SIZE_ERR = 2;
DOMException.HIERARCHY_REQUEST_ERR = 3;
DOMException.WRONG_DOCUMENT_ERR = 4;
DOMException.INVALID_CHARACTER_ERR = 5;
DOMException.NO_DATA_ALLOWED_ERR = 6;
DOMException.NO_MODIFICATION_ALLOWED_ERR = 7;
DOMException.NOT_FOUND_ERR = 8;
DOMException.NOT_SUPPORTED_ERR = 9;
DOMException.INUSE_ATTRIBUTE_ERR = 10;
DOMException.INVALID_STATE_ERR = 11;
DOMException.SYNTAX_ERR = 12;
DOMException.INVALID_MODIFICATION_ERR = 13;
DOMException.NAMESPACE_ERR = 14;
DOMException.INVALID_ACCESS_ERR = 15;
DOMException.VALIDATION_ERR = 16;
DOMException.TYPE_MISMATCH_ERR = 17;


var DOMTokenList = function(getter, setter) { // TODO parameter checking
	this._getText = getter;
	this._setText = setter;
	this.valueOf = getter;
	this.toString = getter;
	this.length = {
		binding: this,
		valueOf: function() { return this.binding._getTokens().length },
		toString: function() { return String(this.valueOf()); }
	};
};
DOMTokenList.prototype.item = function(index) {
	return this._getTokens()[index];		
}
DOMTokenList.prototype.has = function(token) {
	return (-1 != Array.indexOf(this._getTokens(), token));
}
DOMTokenList.prototype.add = function(token) {
	var tokens = this._getTokens();
	if (!this.has(token)) {
		var text = this._getText().replace(/\s*$/, " " + token);
		this._setText(text);
	}
}
DOMTokenList.prototype.remove = function(token) {
	if (this.has(token)) {
		var rex, text = this._getText();
		rex = RegExp("\\s+"+token+"\\s+", "g");
		text = text.replace(rex, " ");
		rex = RegExp("^\\s*"+token+"\\s+");
		text = text.replace(rex, "");
		rex = RegExp("\\s+"+token+"\\s*$");
		text = text.replace(rex, "");
		if (text == token) text = "";
		this._setText(text);
	}		
}
DOMTokenList.prototype.toggle = function(token) {
	if (this.has(token)) this.remove(token);
	else this.add(token);		
}
DOMTokenList.prototype._getTokens = function() {
	var text = this._getText();
	if (!text) return [];
	var strings = text.split(/\s+/);
	var sorted = strings.sort();
	for (var i=sorted.length-1; i>0; i--) {
		if (sorted[i] == sorted[i-1]) sorted.splice(i);
	}
	return sorted;		
}

/*
	DOMWalker supports the forEach method which walks the DOM (depth first)
	starting at the given element and calling the given function for every element.
*/
DOMWalker = function(element) {
	this.root = element || document.documentElement;
	this.current = null;
	this.index = 0;
}

DOMWalker.forEach = function(element, fn, context) { // TODO redo as per DOMWalker.prototype.forEach
	var node = element;
	var next = element;
	var index = 0; // or should this be an xpath like expression?
	do {
		index++;
		if (Node.ELEMENT_NODE == node.nodeType) fn.call(context, node, index, element);
		next = node.firstChild || node.nextSibling;
		while (!next) {
			node = node.parentNode;
			if (element == node) break;
			next = node.nextSibling;
		}
		if (next) node = next;
	} while (node != element);
}


DOMWalker.prototype.forEach = function(fn, context) {
	if (!this.current) {
		this.current = this.root;
		this.index++;
		fn.call(context, this.current, this.index, this.root); // assumes root is an element
	}

	OUTER: for (;;) {
		var next = this.current.firstChild;
		while (next && (Node.ELEMENT_NODE != next.nodeType || "xml" == next.tagName.toLowerCase())) next = next.nextSibling;
		var up = this.current;
		INNER: while (!next) {
			if (this.root == up) break OUTER;
			next = up.nextSibling;
			while (next && (Node.ELEMENT_NODE != next.nodeType || "xml" == next.tagName.toLowerCase())) next = next.nextSibling;
			up = up.parentNode;
		}
		this.current = next;
		this.index++;
		if (Node.ELEMENT_NODE == this.current.nodeType) fn.call(context, this.current, this.index, this.root);
	}
	
	return this.current;
}

return {
	Node: Node,
	Text: Text,
	Document: Document,
	Element: Element,
	DOMException: DOMException,
	DOMTokenList: DOMTokenList,
	DOMWalker: DOMWalker
};

})();

enhance(window, Meeko.DOM.Core);


Meeko.DOM.HTML = (function() {
	
var HTMLCollection = function() {}
var HTMLOptionsCollection = function() {}
var HTMLDocument = function() {};
var HTMLElement = function() {}


return {
	HTMLCollection: HTMLCollection,
	HTMLOptionsCollection: HTMLOptionsCollection,
	HTMLDocument: HTMLDocument,
	HTMLElement: HTMLElement
};

})();

enhance(window, Meeko.DOM.HTML);


(function() { // A few cross-browser fixes

if (!document.parentWindow) document.parentWindow = window;

//	document.documentURI for a range of browsers
var _documentURI = document.documentURI || document.baseURI || document.URL || document.url || document.location;
if (!document.documentURI) document.documentURI = _documentURI;

// make abbr and output parse on Internet Explorer 
document.createElement("abbr");
document.createElement("output");

if (!document.importNode) document.importNode = Document.prototype.importNode;

// make visible window["[[DOMDocument]]"], etc in Safari-2
document.createElement("select").options;
document.createTextNode("text");
document.createAttribute("attribute");

var safari2Prototypes = {
	Node: "[[DOMNode.prototype]]",
	Text: "[[DOMText.prototype]]",
	Document: "[[DOMDocument.prototype]]",
	Element: "[[DOMElement.prototype]]",
	Event: "[[DOMEvent.prototype]]"
}

for (var name in safari2Prototypes) {
	var proto = safari2Prototypes[name];
	if (!window[name]) window[name] = {};
	if (!window[name].prototype && window[proto]) window[name].prototype = window[proto];
}

})();


Meeko.stuff.domSystem = (function() {

var interfaceTable = [
	{ name: "Node", attachTo: "node" },
	{ name: "Text", attachTo: "text", base: "Node" },
	{ name: "Element", attachTo: "element", base: "Node" },
	{ name: "HTMLElement", attachTo: "element", base: "Element" },
	{ name: "Document", attachTo: "document", base: "Node" },
	{ name: "HTMLDocument", attachTo: "document", base: "Document" },
	{ name: "Window", attachTo: "window" }
];

var interfacesByName = {};
forEach (interfaceTable, function(row) {
	interfacesByName[row.name] = row;
})


/*
elementBinding = function() {}
	prototype: {},
	implementation: function() {},
		prototype: {},
	handlers: []
*/


var privateKey = Math.random();

function copy(dst, src, fields, override) { // TODO maybe this should be a method on Object
	function _copy(name) {
		if (!override && (dst.hasOwnProperty && dst.hasOwnProperty(name) || dst[name] != null)) return;
		dst[name] = src[name];
	}
	if (fields && fields.length) {
		for (var n=fields.length, i=0; i<n; i++) {
			var name = fields[i];
			_copy(name);
		}
	}
	else {
		for (var name in src) _copy(name);
	}
	return dst;
}

function bind(dst, src, fields, override) {
	function _bind(name) {
		if (src[name] == null) return;
		if (!override && (dst.hasOwnProperty && dst.hasOwnProperty(name) || dst[name] != null)) return;
		if ("function" == typeof src[name]) dst[name] = function() { return src[name].apply(src, arguments); };
		else if (dst.__defineGetter__) dst.__defineGetter__(name, function() { return src[name]; });
		else dst[name] = src[name];
	}
	if (fields && fields.length) {
		for (var n=fields.length, i=0; i<n; i++) {
			var name = fields[i];
			_bind(name);
		}
	}
	else {
		for (var name in src) _bind(name);
	}
	return dst;
}

function applyBindingImplementation(target, bindingImplementation) {
	var binding = new bindingImplementation(target);
	if (binding.xblBindingAttached) binding.xblBindingAttached();
	return binding;
}

function removeBindingImplementation(target, binding) {
	if (binding.xblBindingDetached) binding.xblBindingDetached();
	if (binding.DESTROY) binding.DESTROY();
}

var domBindings = {};

var createDOMBinding = function(name) {
	var domBinding = {};
	domBinding.name = name;
	domBinding.interfaces = [];

	domBinding.apply = function(element) {
		var ifName = "_" + this.name;
		var n = this.interfaces.length;
		element[ifName] = new Array(n);
		for (var i=0; i<n; i++) {
			var iface = this.interfaces[i];
			if (iface.apply) iface.apply(element);
			if (iface.implementation) element[ifName][i] = applyBindingImplementation(element, iface.implementation);
		}
	}
	
	domBinding.remove = function(element) { // FIXME
		var ifName = "_" + this.name;
		var n=this.interfaces.length;
		for (i=n-1; i>0; i--) {
			var iface = this.interfaces[i];
			removeBindingImplementation(element, element[ifName][i]);
			if (iface.remove) iface.remove(element);
		}
		element[ifName] = null;
//		delete element[ifName];
	}

	domBinding.implementation = function(target) {
		for (var n=domBinding.interaces.length, i=0; i<n; i++) {
			domBinding.interfaces[i].implementation.apply(this);
		}
	}
	
	domBinding.addBinding = function(bindingSpec) {
		var ifName = "_" + this.name;
		this.interfaces.push(bindingSpec);
		var index = this.interfaces.length - 1;
		return Function("element", "var iface = element."+ifName+"; if (iface) return iface["+index+"];");
	}
	
	domBinding.init = function() {
		for (var n=this.interfaces.length, i=0; i<n; i++) {
			var iface = this.interfaces[i];
			if (iface.prototype) copy(this.prototype, iface.prototype);
			if (iface.implementation && iface.implementation.prototye) copy(this.implementation.prototype, iface.implementation.prototype);			
		}
	}

	domBindings[name] = domBinding;
	if (window[name]) domBindings[name].prototype = window[name];
	else window[name] = domBindings[name];
	return domBinding;
}

for (var name in interfacesByName) {
	createDOMBinding(name);
}

function installBinding(name, binding) {
	return domBindings[name].addBinding(binding);
}

var registeredSystems = [];
function registerSystem(sys) {
	registeredSystems.push(sys);
}

var timerId = null,
	readyState = "uninitialized",
	_initializing = false,
	view = null,
	domWalker = null;

function init() {
	if (null == document.readyState) { // Mozilla
		document.readyState = "loading";	
		document.addEventListener("DOMContentLoaded", function(event) { document.readyState = "loaded"; }, true);
		window.addEventListener("load", function(event) { if (event.target == document || event.target == window) document.readyState = "complete"; }, true);
	}
	
	if (window.addEventListener) window.addEventListener("unload", exit, true);
	if (window.attachEvent) window.attachEvent("onunload", exit);	

	timerId = window.setTimeout(onprogress, 50);
}

function exit() { // FIXME
	var domWalker = new DOMWalker(view);
	domWalker.forEach(function(element) {
		domBindings["Element"].remove(element);
		domBindings["HTMLElement"].remove(element);
	});

	for (var n=registeredSystems.length, i=0; i<n; i++) { 
		var system = registeredSystems[i];
		if (system.exit) system.exit();
	}

	if (window.removeEventListener) window.removeEventListener("unload", exit, false);
	if (window.detachEvent) window.detachEvent("onunload", exit);
}

function onprogress() {
	if (_initializing) { // NOTE re-entrancy has been observed on several browsers. Might be a bug in the design
		;;;logger.debug("Re-entrancy during initialization");
		return false; 
	}
	_initializing = true;
	_init();
	_initializing = false;
}

function _init() {
	timerId = window.setTimeout(onprogress, 50);
	MAIN: switch (readyState) { // NOTE all these branches can fall-thru when they result in a state transition
		case "uninitialized":
			if (!document.body) return false;
			view = document.body;
			for (var name in domBindings) {
				domBindings[name].init();
			}
			domBindings["Window"].apply(window);
			domBindings["Document"].apply(document);
			domBindings["HTMLDocument"].apply(document);
			for (var n=registeredSystems.length, i=0; i<n; i++) {
				var system = registeredSystems[i];
				if (system.init) system.init();
			}
			domWalker = new DOMWalker(view);
			readyState = "loading";
		case "loading":
			domWalker.forEach(function(element) {
				domBindings["Element"].apply(element);
				domBindings["HTMLElement"].apply(element);
			});
			// FIXME if document.readyState is updated while this thread is running then there could be a failure here.
			switch (document.readyState) {
				case "loaded": case "interactive": case "complete":	readyState = "loaded"; break;
				default: break MAIN;
			}
		case "loaded":
			for (var n=registeredSystems.length, i=0; i<n; i++) {
				if ("complete" != registeredSystems[i].readyState) break MAIN;
			}
			readyState = "complete";
	}
	
	// NOTE it is an error if we don't get to this point
	var event = document.createEvent("Event");
	event.initEvent("progress", true, true);
	Meeko.stuff.eventSystem.windowEventTarget.dispatchEvent(event);
	if (readyState == "complete") {
		var event = document.createEvent("Event");
		event.initEvent("load", true, true);
		Meeko.stuff.eventSystem.windowEventTarget.dispatchEvent(event);
		window.clearTimeout(timerId);
	}
}

init();

return {
	registerSystem: registerSystem,
	installBinding: installBinding,
	bindInterface: bind
}

})();



Meeko.DOM.Events = (function() {

var privateKey = Math.random();

function copy(dst, src, fields, override) { // TODO maybe this should be a method on Object
	function _copy(name) {
		if (override || (dst.hasOwnProperty && !dst.hasOwnProperty(name)) || dst[name] == null) dst[name] = src[name]; // TODO is this correct?
	}
	if (fields && fields.length) {
		for (var n=fields.length, i=0; i<n; i++) {
			var name = fields[i];
			_copy(name);
		}
	}
	else {
		for (var name in src) _copy(name);
	}
	return dst;
}

function addBinding(target, bindingSpec) {
	var binding = new bindingSpec;
	binding.boundElement = target;
	for (var key in bindingSpec.prototype) {
		if (/^xbl/.test(key)) continue; // filter out xbl* methods
		(function(method) {
			target[method] = function() { return bindingSpec.prototype[method].apply(binding, arguments); }
		})(key);
	}
	if (binding.xblBindingAttached) binding.xblBindingAttached();
	return binding;
}

var w3cEventsTable = [
	{ type: "DOMActivate", bubbles: true, cancelable: true, module: "UIEvent" },
	{ type: "DOMFocusIn", bubbles: true, cancelable: false, module: "UIEvent" },
	{ type: "DOMFocusOut", bubbles: true, cancelable: false, module: "UIEvent" },
	{ type: "focus", bubbles: false, cancelable: false, module: "UIEvent" },
	{ type: "blur", bubbles: false, cancelable: false, module: "UIEvent" },
	{ type: "textInput", bubbles: true, cancelable: true, module: "TextEvent" },
	{ type: "click", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "dblclick", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "mousedown", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "mouseup", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "mouseover", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "mousemove", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "mouseout", bubbles: true, cancelable: true, module: "MouseEvent" },
	{ type: "keydown", bubbles: true, cancelable: true, module: "KeyboardEvent" },
	{ type: "keyup", bubbles: true, cancelable: true, module: "KeyboardEvent" },
	{ type: "mousemultiwheel", bubbles: true, cancelable: true, module: "MouseMultiWheelEvent" },
	{ type: "mousewheel", bubbles: true, cancelable: true, module: "MouseWheelEvent" },
	{ type: "DOMSubtreeModified", bubbles: true, cancelable: false, module: "MutationEvent" },
	{ type: "DOMNodeInserted", bubbles: true, cancelable: false, module: "MutationEvent" },
	{ type: "DOMNodeRemoved", bubbles: true, cancelable: false, module: "MutationEvent" },
	{ type: "DOMNodeRemovedFromDocument", bubbles: false, cancelable: false, module: "MutationEvent" },
	{ type: "DOMNodeInsertedIntoDocument", bubbles: false, cancelable: false, module: "MutationEvent" },
	{ type: "DOMAttrModified", bubbles: true, cancelable: false, module: "MutationEvent" },
	{ type: "DOMCharacterDataModified", bubbles: true, cancelable: false, module: "MutationEvent" },
	{ type: "DOMElementNameChanged", bubbles: true, cancelable: false, module: "MutationNameEvent" },
	{ type: "DOMAttributeNameChanged", bubbles: true, cancelable: false, module: "MutationNameEvent" },
	{ type: "load", bubbles: false, cancelable: false, module: "Event" },
	{ type: "unload", bubbles: false, cancelable: false, module: "Event" },
	{ type: "abort", bubbles: true, cancelable: false, module: "Event" },
	{ type: "error", bubbles: true, cancelable: false, module: "Event" },
	{ type: "select", bubbles: true, cancelable: false, module: "Event" },
	{ type: "change", bubbles: true, cancelable: false, module: "Event" },
	{ type: "submit", bubbles: true, cancelable: true, module: "Event" },
	{ type: "reset", bubbles: true, cancelable: true, module: "Event" },
	{ type: "resize", bubbles: true, cancelable: false, module: "UIEvent" },
	{ type: "scroll", bubbles: true, cancelable: false, module: "UIEvent" },
	{ type: "keypress", bubbles: true, cancelable: true, module: "KeyboardEvent" }, // non-standard
	{ type: "DOMContentLoaded", bubbles: true, cancelable: false, module: "Event" } // mozilla
];

var eventsByType = {};
for (var i=0, n=w3cEventsTable.length; i<n; i++) {
	var row = w3cEventsTable[i];
	var type = row["type"];
	eventsByType[type] = row;
}

var eventsByModule = {};
for (var i=0, n=w3cEventsTable.length; i<n; i++) {
	var row = w3cEventsTable[i];
	var type = row["type"];
	var module = row["module"];
	if (!eventsByModule[module]) eventsByModule[module] = {};
	eventsByModule[module][type] = row;
}


var w3cKeyIdentifiers = {
	"U+007F": 46, // Delete
	"U+0008": 8, // Backspace
	"U+001B": 27, // Escape
	Down: 40, End: 35, Enter: 13, Home: 36, Insert: 45,
	Left: 37, PageUp: 33, PageDown: 34, Right: 39, Up: 38,
	F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123
}

var keyIdentifiersByCode = {};
for (var keyId in w3cKeyIdentifiers) {
	var code = w3cKeyIdentifiers[keyId];
	keyIdentifiersByCode[code] = keyId;
}

var toHexDigit = "0123456789ABCDEF".split(/\s*/);
for (var i=0; i<=15; i++) {
	for (var j=0; j<=15; j++) {
		var hex = "" + toHexDigit[i] + toHexDigit[j];
		var code = Number("0x"+hex);
		var keyId = "U+00" + hex;
		if (!keyIdentifiersByCode[code]) keyIdentifiersByCode[code] = keyId;		
	}
}

var safari2bouncyKeys; 
if (/AppleWebKit/.test(navigator.userAgent) && Number(navigator.userAgent.match(/[0-9]+\.[0-9]+$/)) < 500) { // FIXME is this correct?
	safari2bouncyKeys = copy({}, w3cKeyIdentifiers);
	delete safari2bouncyKeys["U+0008"];	
}

var EventState = function() {}
// These states are set by the EventSystem, so won't be valid for general use
EventState.DEFAULT_PREVENTED = 0x01; 
EventState.PROPAGATION_STOPPED = 0x02;
EventState.FAKE_EVENT = 0x04;
EventState.COMPATIBILITY_EVENT = 0x08;

var WindowEventTarget = function() {}; // TODO implement by extending EventTarget

WindowEventTarget.prototype.xblBindingAttached = function() {
	this.listenerTable = {}; // lookup by this.listenerTable[type][Boolean(capture)][index]
	this.handleEvent = function(event, phase) { // FIXME
		if (!phase) phase = event.eventPhase; 
		var capture = (phase == Event.CAPTURING_PHASE) ? 1 : 0;
		var table = this.listenerTable[event.type];
		if (!table) return;
		var listeners = table[capture];
		for (var n=listeners.length, i=0; i<n; i++) {
			var listener = listeners[i];
			try {
				if (listener.handleEvent) return listener.handleEvent(event);
				else return listener(event);
			}
			catch (error) {
				logger.error("Error in event listener: " + error);
				return;
			}
		}
	}
}

WindowEventTarget.prototype.addEventListener = function(type, listener, useCapture) {
	if (!this.listenerTable[type]) this.listenerTable[type] = [ [], [] ];
	var capture = (useCapture) ? 1 : 0;
	this.listenerTable[type][capture].push(listener);
}

WindowEventTarget.prototype.removeEventListener = function(type, listener, useCapture) {
	var capture = (useCapture) ? 1 : 0;
	var listeners;
	if (this.listenerTable[type]) listeners = this.listenerTable[type][capture];
	else return; // TODO logger.warn
	for (var i=listeners.length-1; i>=0; i--) {
		if (listeners[i] == listener) {
			listeners.splice(i, 1);
			break;
		}
	}
	// TODO warn on not found??
}

WindowEventTarget.prototype.dispatchEvent = function(event) { // FIXME 
	if (event.type == "loadFirebugConsole") window.__proto__.dispatchEvent.call(window, event); // NOTE needed for firebug
	this.handleEvent(event, 1); // capture
	this.handleEvent(event, 2); // target
	// throw "dispatchEvent method not available on Window objects";
}

var EventSystem = function() {
	var eventSystem = this;
	this.registeredEvents = {};
	this.keyEventHistory = [];
	this.eventListener = function(event) {
		eventSystem.handleEvent(event);
	}
	if (window.addEventListener) {
		for (var type in eventsByType) {
			window.addEventListener(type, this.eventListener, true);
		}
	}

	this.windowEventTarget = addBinding(window, WindowEventTarget);
}


EventSystem.prototype.handleEvent = function(event) { // TODO refactor
	var keyEventFields = [ "type", "keyCode", "charCode", "keyIdentifier" ];
	var eventHandlersByType = {
		"load": function(event) {
			if (event.target != document && event.target != window) return;
			this.windowEventTarget.handleEvent(event);
			logger.debug("Browser load event received.");
			event.stopPropagation();
			return false;
		},
		"keydown": function(event) {
			var keyId;
			if (event.keyIdentifier) keyId = event.keyIdentifier;
			else {
				keyId = keyIdentifiersByCode[event.keyCode];
				event.keyIdentifier = keyId;
			}
			var hist = this.keyEventHistory;
			var n = hist.length;
			var prev = (n) ? hist[n-1] : null;
			var repeat = 0;
			var delta = 1;
			if (safari2bouncyKeys && keyId in safari2bouncyKeys) { // TODO refactor
				repeat = -0.5;
				delta = 0.5;
			}
			if (prev && prev.type == "keydown") repeat = prev.repeat + delta;
			else if (prev && prev.type == "keypress") repeat = prev.repeat + delta;
			event.repeat = repeat;
			hist.push(copy({ type: "keydown", repeat: repeat }, event, keyEventFields));
			if (event.eventStatus & EventState.DEFAULT_PREVENTED) event.preventDefault(); // signal from keypress
			if (repeat % 1) { // ignore bouncy key registrations
				event.stopPropagation();
			}
			else {
				this.windowEventTarget.handleEvent(event);
			}		
		},
		"keypress": function(event) {
			var keyId;
			if (event.keyIdentifier) keyId = event.keyIdentifier;
			else {
				keyId = keyIdentifiersByCode[event.keyCode];
				event.keyIdentifier = keyId;
			}
			var hist = this.keyEventHistory;
			var n = hist.length;
			var prev = (n) ? hist[n-1] : null;
			var repeat = 0;
			var delta = 1;
			if (safari2bouncyKeys && keyId in safari2bouncyKeys) { // TODO refactor
				repeat = -0.5;
				delta = 0.5;
			}
			if (prev && prev.type == "keydown") repeat = prev.repeat;
			else if (prev && prev.type == "keypress") repeat = prev.repeat + delta;
			
			if (!(prev && prev.type == "keydown")) {
				event.stopPropagation();
				var newEvent;
				try { // FIXME does this work on all platforms?? In any case, it should be moved into document.createEvent, etc
					newEvent = document.createEvent("KeyboardEvent");
					if (newEvent.initKeyboardEvent) {
						newEvent.initKeyboardEvent("keydown", true, true, window, keyId, 0, "");						
					}
					else if (newEvent.initKeyEvent) {
						newEvent.initKeyEvent("keydown", true, true, window, false, false, false, false, event.keyCode, event.charCode);
					}
				}
				catch (error) {
					newEvent = document.createEvent("UIEvents");
					newEvent.initEvent("keydown", true, true);
					newEvent.keyIdentifier = keyId;
					newEvent.keyCode = event.keyCode;
				}
				newEvent.eventStatus = 0x01 | 0x08; // signal to handler to prevent default
				event.target.dispatchEvent(newEvent);
			}
			if (keyId in w3cKeyIdentifiers) {
				event.stopPropagation();
			}
			else {
				event.stopPropagation();
				var newEvent = document.createEvent("TextEvent");
				newEvent.initTextEvent("textInput", true, true, window, String.fromCharCode(event.keyCode));
				event.target.dispatchEvent(newEvent);
			}
			hist.push(copy({ type: "keypress", repeat: repeat }, event, keyEventFields));			
		},
		"textInput": function(event) {
			var hist = this.keyEventHistory;
			var n = hist.length;
			var prev = (n) ? hist[n-1] : null;
			if (prev && prev.type == "keydown") {
				this.windowEventTarget.handleEvent(event);
				hist.push(copy({ type: "textInput" }, event, keyEventFields));
			}			
		},
		"keyup": function(event) {
			var keyId;
			if (event.keyIdentifier) keyId = event.keyIdentifier;
			else {
				keyId = keyIdentifiersByCode[event.keyCode];
				event.keyIdentifier = keyId;
			}
			var hist = this.keyEventHistory;
			var n = hist.length;
			var prev = hist[n-1];
			if (prev && (prev.type != "keyup" || prev.keyIdentifier != keyId)) {
				hist.push(copy({ type: "keyup" }, event, keyEventFields));
				this.windowEventTarget.handleEvent(event);
			}			
		}
	}
	var handler = eventHandlersByType[event.type] || function(event) { this.windowEventTarget.handleEvent(event); };
	if (handler) handler.call(this, event);
}

EventSystem.prototype.registerEvent = function(type) {
	if (this.registeredEvents[type]) return;
	var system = this;
	var systemListener = function(srcEvent) {
		system.dispatchEvent(srcEvent.srcElement, srcEvent);
	}

	var ieLookup = { // FIXME ensure all standard event properties are copied / created
		"DOMAttrModified": { type: "propertychange", bubbles: false, cancelable: false },
		"DOMActivate": { type: "activate", bubbles: true, cancelable: true },
		"DOMFocusIn": { type: "focusin", bubbles: true, cancelable: false },
		"DOMFocusOut": { type: "focusout", bubbles: true, cancelable: false },
		"keydown": function() {
			document.attachEvent("onkeydown", function(srcEvent) {
				var event = document.createEvent("UIEvents");
				event.initEvent("keydown", true, true);
				event.keyCode = srcEvent.keyCode;
				event.keyIdentifier = keyIdentifiersByCode[srcEvent.keyCode];
				event.returnValue = system.dispatchEvent(srcEvent.srcElement, event);
				return event.returnValue;
			});
		},
		"keyup": function() {
			document.attachEvent("onkeyup", function(srcEvent) {
				var event = document.createEvent("UIEvents");
				event.initEvent("keyup", true, true);
				event.keyCode = srcEvent.keyCode;
				event.keyIdentifier = keyIdentifiersByCode[srcEvent.keyCode];
				event.returnValue = system.dispatchEvent(srcEvent.srcElement, event);
				return event.returnValue;
			});
		},
		"textInput": function() {
			window.attachEvent("onkeypress", function(srcEvent) {
				var event = document.createEvent("UIEvents");
				event.initEvent("textInput", true, true);
				event.data = String.fromCharCode(srcEvent.keyCode);
				srcEvent.returnValue = system.dispatchEvent(srcEvent.srcElement, event);
			});
		},
		"focus": function() {
			window.attachEvent("onfocusin", function(srcEvent) {
				var event = document.createEvent("UIEvents");
				event.initEvent("focus", false, false);
				srcEvent.returnValue = system.dispatchEvent(srcEvent.srcElement, event);
			});
		},
		"blur": function() {
			window.attachEvent("onfocusout", function(srcEvent) {
				var event = document.createEvent("UIEvents");
				event.initEvent("blur", false, false);
				srcEvent.returnValue = system.dispatchEvent(srcEvent.srcElement, event);
			});
		},
		"click": function() {
			document.attachEvent("onclick", function(srcEvent) {
				var event = document.createEvent("UIEvents");
				event.initEvent("click", true, true);
				event.button = ([ null, 0, 2, null, 1 ])[srcEvent.button];
				event.detail = 1;
				srcEvent.returnValue = system.dispatchEvent(srcEvent.srcElement, event);
			});
		},
		"dblclick": function() {
			document.attachEvent("ondblclick", function(srcEvent) {
				var event = document.createEvent("UIEvents");
				event.initEvent("dblclick", true, true);
				event.button = ([ null, 0, 2, null, 1 ])[srcEvent.button];
				event.detail = 2;
				srcEvent.returnValue = system.dispatchEvent(srcEvent.srcElement, event);
			});
		}
	}

	var rego = ieLookup[type] || { type: type, bubbles: true, cancelable: true};

	if (typeof rego == "function") rego();
	else document.attachEvent("on"+rego.type, systemListener);
	this.registeredEvents[type] = true;
}

EventSystem.prototype.dispatchEvent = function(target, event) {
	event.target = target;
	var path = [];
	var current = target;
	if (target != window) {
		for (current=target; current!=document; current=current.parentNode) { // FIXME will fail for document fragments, etc
			path.push(current);
		}
		path.push(document);
	}
	path.push(window);

	event.eventPhase = Event.CAPTURING_PHASE;
	for (var n=path.length, i=n-1; i>0; i--) {
		current = path[i];
		event.currentTarget = current;
		var eventTarget = EventTarget(current);
		if (eventTarget) eventTarget.handleEvent(event);
		if (event.cancelBubble) return event.returnValue; 
	}

	current = path[0];
	event.eventPhase = Event.AT_TARGET;
	event.currentTarget = current;
	var eventTarget = EventTarget(current);
	if (eventTarget) eventTarget.handleEvent(event);

	if (!event.bubbles) return event.returnValue;
	if (event.cancelBubble) return event.returnValue;

	event.eventPhase = Event.BUBBLING_PHASE;
	for (var n=path.length, i=1; i<n; i++) {
		current = path[i];
		event.currentTarget = current;
		var eventTarget = EventTarget(current);
		if (eventTarget) eventTarget.handleEvent(event);
		if (event.cancelBubble) return event.returnValue; 
	}
	
	return event.returnValue;	
}

var eventSystem = new EventSystem;

var Event = function(key) {
	if (key != privateKey) throw "Event is not a constructor";
};
Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;
Event.prototype.initEvent = function(type, bubbles, cancelable) {
	this.eventStatus = 0;
	this.timeStamp = Number(new Date);
	this.type = type;
	this.bubbles = Boolean(bubbles);
	this.cancelable = Boolean(cancelable);
}

Event.prototype.preventDefault = function() { this.eventStatus |= EventState.DEFAULT_PREVENTED; }
Event.prototype.stopPropagation = function() { this.eventStatus |= EventState.PROPAGATION_STOPPED; }


var CustomEvent = function(key) {
	if (key != privateKey) throw "CustomEvent is not a constructor";
};
CustomEvent.prototype = new Event(privateKey);
CustomEvent.prototype.initCustomEvent = function(type, bubbles, cancelable, detail) {
	this.initEvent(type, bubbles, cancelable);
	this.detail = detail;
}

var UIEvent = function(key) {
	if (key != privateKey) throw "UIEvent is not a constructor";
};
UIEvent.prototype = new Event(privateKey);
UIEvent.prototype.initUIEvent = function(type, bubbles, cancelable, view, detail) {
	this.initEvent(type, bubbles, cancelable);
	this.view = view;
	this.detail = detail;
}

var TextEvent = function(key) {
	if (key != privateKey) throw "TextEvent is not a constructor";
};
TextEvent.prototype = new UIEvent(privateKey);
TextEvent.DOM_KEY_LOCATION_STANDARD = 0x00;
TextEvent.DOM_KEY_LOCATION_LEFT = 0x01;
TextEvent.DOM_KEY_LOCATION_RIGHT = 0x02;
TextEvent.DOM_KEY_LOCATION_NUMPAD = 0x03;
TextEvent.prototype.initTextEvent = function(type, bubbles, cancelable, view, data) {
	this.initUIEvent(type, bubbles, cancelable, view, 0);
	this.data = data;
}

var KeyboardEvent = function(key) {
	if (key != privateKey) throw "KeyboardEvent is not a constructor";
};
KeyboardEvent.prototype = new UIEvent(privateKey);
KeyboardEvent.DOM_KEY_LOCATION_STANDARD = 0x00;
KeyboardEvent.DOM_KEY_LOCATION_LEFT = 0x01;
KeyboardEvent.DOM_KEY_LOCATION_RIGHT = 0x02;
KeyboardEvent.DOM_KEY_LOCATION_NUMPAD = 0x03;
KeyboardEvent.prototype.initKeyboardEvent = function(type, bubbles, cancelable, view, keyIdentifier, keyLocation, modifierList) {
	this.initUIEvent(type, bubbles, cancelable, view, 0);
	this.keyIdentifier = keyIdentifier;
	this.keyLocation = keyLocation;
	this._modifiers = modifierList.split(" ");
	for (var n=this._modifiers.length, i=0; i<n; i++) {
		switch (this._modifiers[i]) {
			case "Alt": this.altKey = true; break;
			case "Control": this.ctrlKey = true; break;
			case "Meta": this.metaKey = true; break;
			case "Shift": this.shiftKey = true; break;
		}
	}
}
KeyboardEvent.prototype.getModifierState = function(keyIdentifier) {
	for (var n=this._modifiers.length, i=0; i<n; i++) {
		if (keyIdentifier == this._modifiers[i]) return true;
	}
	return false;
}

var MouseEvent = function(key) {
	if (key != privateKey) throw "MouseEvent is not a constructor";
};
MouseEvent.prototype = new UIEvent(privateKey);
MouseEvent.prototype.initMouseEvent = function(type, bubbles, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget) {
	var xplParams = [ "type", "bubbles", "cancelable", "view", "detail", "screenX", "screenY", "clientX", "clientY", "ctrlKey", "altKey", "shiftKey", "metaKey", "button", "relatedTarget" ]
	var n = xplParams.length;
	if (arguments.length < n) throw "Improper argument list in call to initMouseEvent"; // FIXME
	this.initUIEvent(type, bubbles, cancelable, view, detail);
	for (var i=5; i<n; i++) {
		var name = xplParams[i];
		this[name] = arguments[i];
	}
}



var MutationEvent = function(key) {
	if (key != privateKey) throw "MutationEvent is not a constructor";
};
MutationEvent.MODIFICATION = 1;
MutationEvent.ADDITION = 2;
MutationEvent.REMOVAL = 3;
MutationEvent.prototype = new Event(privateKey);
MutationEvent.prototype.initMutationEvent = function(type, bubbles, cancelable) {
	var xplParams = [ "type", "bubbles", "cancelable", "relatedNode", "prevValue", "newValue", "attrName", "attrChange" ]
	var n = xplParams.length;
	if (arguments.length < n) throw "Improper argument list in call to initMutationEvent"; // FIXME
	this.initEvent(type, bubbles, cancelable);
	for (var i=3; i<n; i++) {
		var name = xplParams[i];
		this[name] = arguments[i];
	}
}


var eventModuleMap = {
	"HTMLEvents": "Event",
	"UIEvents": "UIEvent",
	"MouseEvents": "MouseEvent",
	"MutationEvents": "MutationEvent"
}


var DocumentEvent = function() {}
if (document.createEventObject) {

var eventTemplates = {
	Event: new Event(privateKey),
	CustomEvent: new CustomEvent(privateKey),
	UIEvent: new UIEvent(privateKey),
	TextEvent: new TextEvent(privateKey),
	KeyboardEvent: new KeyboardEvent(privateKey),
	MouseEvent: new MouseEvent(privateKey),
	MutationEvent: new MutationEvent(privateKey)	
}

DocumentEvent.prototype.createEvent = function(module) {
	var dom3Module = eventModuleMap[module] || module;
	var tmp = eventTemplates[dom3Module];
	if (!tmp) throw "Invalid event module: " + module;
	var event = document.createEventObject();
	copy(event, tmp);
	event.preventDefault = function() { this.returnValue = false; }
	event.stopPropagation = function() { this.cancelBubble = true; }
	return event;
}

var documentEvent = addBinding(document, DocumentEvent);

}

if (!document.addEventListener && document.attachEvent) {

var EventTarget = function(target) {
	if (null == target || window != this) return;
	return arguments.callee.getInterface(target);	
}

EventTarget.interfaceLookup = new Array(13); // NOTE potentially one for every node type + Window
EventTarget.interfaceLookup[0] = Meeko.stuff.domSystem.installBinding("Window", EventTarget);
EventTarget.interfaceLookup[Node.DOCUMENT_NODE] = Meeko.stuff.domSystem.installBinding("Document", EventTarget);
EventTarget.interfaceLookup[Node.ELEMENT_NODE] = Meeko.stuff.domSystem.installBinding("Element", EventTarget);
EventTarget.getInterface = function(target) {
	var lookup = this.interfaceLookup[target.nodeType];
	return (lookup) ? lookup(target) : null;
	
}
EventTarget.implementation = function(element) {
	this.boundElement = element;
	Meeko.stuff.domSystem.bindInterface(element, this, ["addEventListener", "removeEventListener", "dispatchEvent"]);
	this.listenerTable = {}; // lookup by this.listenerTable[type][Boolean(capture)][index]
}

EventTarget.implementation.prototype.handleEvent = function(event) {
	var capture = (event.eventPhase == Event.CAPTURING_PHASE) ? 1 : 0;
	var table = this.listenerTable[event.type];
	if (!table) return;
	var listeners = table[capture];
	for (var n=listeners.length, i=0; i<n; i++) {
		var listener = listeners[i];
		try {
			if (listener.handleEvent) return listener.handleEvent(event);
			else return listener(event);
		}
		catch (error) {
			logger.error("Error in event listener: " + error);
			return;
		}
	}
}

EventTarget.implementation.prototype.addEventListener = function(type, listener, useCapture) {
	if (!this.listenerTable[type]) this.listenerTable[type] = [ [], [] ];
	var capture = (useCapture) ? 1 : 0;
	this.listenerTable[type][capture].push(listener);
	eventSystem.registerEvent(type);
}

EventTarget.implementation.prototype.removeEventListener = function(type, listener, useCapture) {
	var capture = (useCapture) ? 1 : 0;
	var listeners = this.listenerTable[type][capture];
	for (var i=listeners.length-1; i>=0; i--) {
		if (listeners[i] == listener) {
			listeners.splice(i, 1);
			break;
		}
	}
	// TODO warn on not found??
}

EventTarget.implementation.prototype.dispatchEvent = function(event) {
	var element = this.boundElement;
	try { return element.fireEvent("on" + event.type, event); }
	catch (error) { return eventSystem.dispatchEvent(element, event); }
}		

}

Meeko.stuff.eventSystem = eventSystem; // FIXME back-door to virtually everything

return {
	Event: Event,
	CustomEvent: CustomEvent,
	UIEvent: UIEvent,
	TextEvent: TextEvent,
	KeyboardEvent: KeyboardEvent,
	MouseEvent: MouseEvent,
	MutationEvent: MutationEvent
}

})();

enhance(window, Meeko.DOM.Events);

if (document.documentElement.classList == null) {

var ClassListBinding = {}
ClassListBinding.apply = function(element) {
	element.classList = new DOMTokenList(function() { return element.className; }, function(val) { element.className = val });
}
ClassListBinding.remove = function(element) {
	element.classList = null;
}

Meeko.stuff.domSystem.installBinding("HTMLElement", ClassListBinding);
}


]]>
</script>
</head>
</html>
